# Code Dump for icn-runtime
# Generated on Wed Apr 23 09:26:46 PM EDT 2025
# --------------------------------

--- FILE: ./agoranet-integration.sh ---
#!/bin/bash
set -euo pipefail

# AgoraNet Integration Script
# Manages the integration between ICN node and AgoraNet

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Default values
COOP_NAME="default"
NODE_URL="http://localhost:26657"
AGORANET_PORT=8080
DAG_PATH="${HOME}/.icn/data/dag"
IDENTITY_PATH="${HOME}/.wallet/identities"
ENABLE_API=true
RUN_AS_DAEMON=false
LOG_FILE="${HOME}/.icn/logs/agoranet.log"
PID_FILE="${HOME}/.icn/agoranet.pid"

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Manage the integration between ICN node and AgoraNet.

Options:
  --coop NAME           Cooperative name (default: default)
  --node-url URL        ICN node RPC URL (default: http://localhost:26657)
  --port PORT           AgoraNet API port (default: 8080)
  --dag-path PATH       Path to DAG data (default: ~/.icn/data/dag)
  --identity-path PATH  Path to identities directory (default: ~/.wallet/identities)
  --no-api              Disable AgoraNet API server
  --daemon              Run AgoraNet as a daemon
  --log-file FILE       Log file path (default: ~/.icn/logs/agoranet.log)
  --start               Start AgoraNet service
  --stop                Stop AgoraNet service
  --status              Check AgoraNet service status
  --restart             Restart AgoraNet service
  --help                Display this help message and exit

Examples:
  # Start AgoraNet for a specific cooperative
  $(basename "$0") --coop "my-cooperative" --start
  
  # Run AgoraNet as a daemon with custom port
  $(basename "$0") --coop "my-cooperative" --port 9090 --daemon --start
  
  # Stop the AgoraNet service
  $(basename "$0") --stop
EOF
}

parse_args() {
  local action=""
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --coop)
        COOP_NAME="$2"
        shift 2
        ;;
      --node-url)
        NODE_URL="$2"
        shift 2
        ;;
      --port)
        AGORANET_PORT="$2"
        shift 2
        ;;
      --dag-path)
        DAG_PATH="$2"
        shift 2
        ;;
      --identity-path)
        IDENTITY_PATH="$2"
        shift 2
        ;;
      --no-api)
        ENABLE_API=false
        shift
        ;;
      --daemon)
        RUN_AS_DAEMON=true
        shift
        ;;
      --log-file)
        LOG_FILE="$2"
        shift 2
        ;;
      --start)
        action="start"
        shift
        ;;
      --stop)
        action="stop"
        shift
        ;;
      --status)
        action="status"
        shift
        ;;
      --restart)
        action="restart"
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done
  
  # Default action is start if no action specified
  if [[ -z "$action" ]]; then
    action="start"
  fi
  
  COMMAND="$action"
}

validate_args() {
  # Ensure cooperative directory exists
  mkdir -p "${IDENTITY_PATH}/${COOP_NAME}"
  
  # Create log directory
  mkdir -p "$(dirname "$LOG_FILE")"
  
  # Validate node connection
  if ! curl -s "${NODE_URL}/status" >/dev/null; then
    log_warn "Cannot connect to ICN node at ${NODE_URL}"
    # Not failing as we might want to start AgoraNet before the node
  fi
  
  # Validate DAG path
  if [[ ! -d "$DAG_PATH" && "$COMMAND" == "start" ]]; then
    log_warn "DAG path does not exist: $DAG_PATH"
    log_info "Creating DAG directory"
    mkdir -p "$DAG_PATH"
  fi
}

start_agoranet() {
  log_info "Starting AgoraNet for cooperative: $COOP_NAME"
  
  # Check if already running
  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid=$(cat "$PID_FILE")
    if ps -p "$pid" > /dev/null; then
      log_warn "AgoraNet is already running with PID $pid"
      return 0
    else
      log_warn "Stale PID file found, removing"
      rm -f "$PID_FILE"
    fi
  fi
  
  # Prepare AgoraNet command
  local cmd="${SCRIPT_DIR}/run-agoranet.sh"
  cmd+=" --coop \"${COOP_NAME}\""
  cmd+=" --port ${AGORANET_PORT}"
  cmd+=" --dag-path \"${DAG_PATH}\""
  [[ "$ENABLE_API" == false ]] && cmd+=" --no-api"
  
  if [[ "$RUN_AS_DAEMON" == true ]]; then
    # Run as daemon
    log_info "Running AgoraNet as daemon"
    
    # Create wrapper script
    local wrapper_script="/tmp/agoranet-wrapper-$$.sh"
    cat > "$wrapper_script" <<EOF
#!/bin/bash
set -euo pipefail
exec $cmd
EOF
    chmod +x "$wrapper_script"
    
    # Start in background
    nohup "$wrapper_script" > "$LOG_FILE" 2>&1 &
    echo $! > "$PID_FILE"
    log_info "AgoraNet started with PID $(cat "$PID_FILE")"
  else
    # Run in foreground
    log_info "Running AgoraNet in foreground"
    eval "$cmd"
  fi
}

stop_agoranet() {
  log_info "Stopping AgoraNet service"
  
  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid=$(cat "$PID_FILE")
    if ps -p "$pid" > /dev/null; then
      log_info "Stopping AgoraNet (PID: $pid)"
      kill "$pid"
      
      # Wait for process to terminate
      for i in {1..30}; do
        if ! ps -p "$pid" > /dev/null; then
          break
        fi
        sleep 1
      done
      
      # Force kill if still running
      if ps -p "$pid" > /dev/null; then
        log_warn "AgoraNet did not terminate gracefully, force killing"
        kill -9 "$pid" || true
      fi
    fi
    rm -f "$PID_FILE"
    log_info "AgoraNet stopped"
  else
    log_warn "No PID file found, AgoraNet may not be running"
  fi
}

check_agoranet_status() {
  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid=$(cat "$PID_FILE")
    if ps -p "$pid" > /dev/null; then
      log_info "AgoraNet is running with PID $pid"
      
      # Check if API is accessible
      if [[ "$ENABLE_API" == true ]]; then
        if curl -s "http://localhost:${AGORANET_PORT}/api/status" >/dev/null; then
          log_info "AgoraNet API is accessible at http://localhost:${AGORANET_PORT}"
        else
          log_warn "AgoraNet process is running but API is not accessible"
        fi
      fi
      
      return 0
    else
      log_warn "PID file exists but process is not running"
      rm -f "$PID_FILE"
      return 1
    fi
  else
    log_info "AgoraNet is not running"
    return 1
  fi
}

restart_agoranet() {
  stop_agoranet
  sleep 2
  start_agoranet
}

# Function to synchronize proposals between AgoraNet and ICN node
sync_proposals() {
  log_info "Synchronizing proposals between AgoraNet and ICN node"
  
  # This is a placeholder - actual implementation would:
  # 1. Fetch existing proposals from the ICN node
  # 2. Fetch proposals from AgoraNet
  # 3. Compare and update as needed
  # 4. Submit any missing proposals to the blockchain
  
  # For now we'll just display a message
  log_info "Proposal synchronization not implemented yet"
}

# Function to manage webhook integrations
setup_webhooks() {
  log_info "Setting up webhooks for AgoraNet integration"
  
  # Create webhook directory
  local webhook_dir="${HOME}/.icn/webhooks"
  mkdir -p "$webhook_dir"
  
  # Create proposal webhook
  local proposal_hook="${webhook_dir}/agoranet-proposal.sh"
  cat > "$proposal_hook" <<EOF
#!/bin/bash
# AgoraNet proposal webhook
set -euo pipefail

# This webhook is called when a new proposal is created in AgoraNet
# It submits the proposal to the ICN blockchain

# Get webhook payload from stdin
read -r PAYLOAD

# Extract proposal details
PROPOSAL_ID=\$(echo "\$PAYLOAD" | jq -r '.proposal_id // empty')
PROPOSAL_TITLE=\$(echo "\$PAYLOAD" | jq -r '.title // empty')
PROPOSAL_CONTENT=\$(echo "\$PAYLOAD" | jq -r '.content // empty')
PROPOSAL_TYPE=\$(echo "\$PAYLOAD" | jq -r '.type // empty')

echo "[$(date)] Received proposal webhook: \$PROPOSAL_ID - \$PROPOSAL_TITLE"

# Submit to blockchain (implementation depends on your ICN node API)
# This is a placeholder for the actual implementation
echo "Submitting proposal to blockchain: \$PROPOSAL_ID"
EOF
  chmod +x "$proposal_hook"
  
  # Create vote webhook
  local vote_hook="${webhook_dir}/agoranet-vote.sh"
  cat > "$vote_hook" <<EOF
#!/bin/bash
# AgoraNet vote webhook
set -euo pipefail

# This webhook is called when a vote is cast in AgoraNet
# It submits the vote to the ICN blockchain

# Get webhook payload from stdin
read -r PAYLOAD

# Extract vote details
PROPOSAL_ID=\$(echo "\$PAYLOAD" | jq -r '.proposal_id // empty')
VOTER_ID=\$(echo "\$PAYLOAD" | jq -r '.voter_id // empty')
VOTE_DECISION=\$(echo "\$PAYLOAD" | jq -r '.decision // empty')

echo "[$(date)] Received vote webhook: Proposal \$PROPOSAL_ID, Voter \$VOTER_ID, Decision \$VOTE_DECISION"

# Submit to blockchain (implementation depends on your ICN node API)
# This is a placeholder for the actual implementation
echo "Submitting vote to blockchain: \$VOTER_ID on proposal \$PROPOSAL_ID"
EOF
  chmod +x "$vote_hook"
  
  log_info "Webhooks set up successfully"
}

main() {
  parse_args "$@"
  validate_args
  
  case "$COMMAND" in
    start)
      start_agoranet
      ;;
    stop)
      stop_agoranet
      ;;
    status)
      check_agoranet_status
      ;;
    restart)
      restart_agoranet
      ;;
    *)
      log_error "Unknown command: $COMMAND"
      print_usage
      exit 1
      ;;
  esac
}

main "$@" 
--- FILE: ./agoranet-proposal-sync.sh ---
#!/bin/bash
set -euo pipefail

# ICN AgoraNet Proposal Sync
# This script synchronizes proposals between AgoraNet and CoVM execution

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Default values
AGORANET_API="http://localhost:8080/api"
NODE_URL="http://localhost:26657"
DATA_DIR="${HOME}/.icn"
LOG_FILE="${DATA_DIR}/logs/agoranet-sync.log"
QUEUE_DIR="${DATA_DIR}/queue"
COOP_NAME="default"
WEBHOOK_TOKEN=""
SYNC_INTERVAL=0  # 0 means run once, >0 means sync every X seconds
VERBOSE=false

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Synchronize proposals between AgoraNet and CoVM execution.

Options:
  --agoranet-api URL    AgoraNet API URL (default: http://localhost:8080/api)
  --node-url URL        ICN node RPC URL (default: http://localhost:26657)
  --data-dir DIR        Data directory (default: ~/.icn)
  --coop NAME           Cooperative name (default: default)
  --webhook-token TOKEN Token for webhook authentication
  --sync-interval SEC   Sync continuously every SEC seconds (default: 0 = once)
  --verbose             Enable verbose logging
  --help                Display this help message and exit

Examples:
  # Run a one-time sync
  $(basename "$0")
  
  # Run continuous sync every 5 minutes
  $(basename "$0") --sync-interval 300
  
  # Sync proposals from a specific AgoraNet instance
  $(basename "$0") --agoranet-api "http://example.com:8080/api"
EOF
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --agoranet-api)
        AGORANET_API="$2"
        shift 2
        ;;
      --node-url)
        NODE_URL="$2"
        shift 2
        ;;
      --data-dir)
        DATA_DIR="$2"
        LOG_FILE="${DATA_DIR}/logs/agoranet-sync.log"
        QUEUE_DIR="${DATA_DIR}/queue"
        shift 2
        ;;
      --coop)
        COOP_NAME="$2"
        shift 2
        ;;
      --webhook-token)
        WEBHOOK_TOKEN="$2"
        shift 2
        ;;
      --sync-interval)
        SYNC_INTERVAL="$2"
        shift 2
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done
}

validate_args() {
  # Create necessary directories
  mkdir -p "$(dirname "$LOG_FILE")"
  mkdir -p "$QUEUE_DIR"
  
  # Check if node is running
  if ! curl -s "${NODE_URL}/status" > /dev/null; then
    log_error "Node is not running at ${NODE_URL}"
    exit 1
  fi
  
  # Check if AgoraNet is accessible
  if ! curl -s --head "${AGORANET_API}/status" > /dev/null; then
    log_error "AgoraNet API not accessible at ${AGORANET_API}"
    exit 1
  fi
}

# Fetch pending proposals from AgoraNet
fetch_pending_proposals() {
  log_info "Fetching pending proposals from AgoraNet"
  
  local proposals_url="${AGORANET_API}/proposals?status=approved"
  local proposals_json
  
  if [[ -n "$WEBHOOK_TOKEN" ]]; then
    proposals_json=$(curl -s -H "Authorization: Bearer ${WEBHOOK_TOKEN}" "$proposals_url")
  else
    proposals_json=$(curl -s "$proposals_url")
  fi
  
  # Check if we got a valid response
  if ! echo "$proposals_json" | jq -e . > /dev/null 2>&1; then
    log_error "Failed to get valid response from AgoraNet"
    return 1
  fi
  
  echo "$proposals_json"
}

# Validate a DSL proposal to ensure it's properly structured
validate_proposal() {
  local proposal_file="$1"
  local proposal_content
  
  proposal_content=$(cat "$proposal_file")
  
  # Check for basic DSL syntax (this is a simple validation)
  if ! grep -q "{" "$proposal_file" || ! grep -q "}" "$proposal_file"; then
    log_error "Proposal file has invalid syntax: $proposal_file"
    return 1
  fi
  
  # Check for required fields in governance proposals
  if grep -q "proposal" "$proposal_file"; then
    if ! grep -q "title:" "$proposal_file"; then
      log_error "Governance proposal missing required 'title' field: $proposal_file"
      return 1
    fi
    
    if ! grep -q "description:" "$proposal_file"; then
      log_error "Governance proposal missing required 'description' field: $proposal_file"
      return 1
    fi
  fi
  
  # If we have the CoVM binary available, use it to validate the DSL
  local covm_path="../deps/icn-covm/target/debug/icn-covm"
  if [[ -x "$covm_path" ]]; then
    log_info "Validating proposal with CoVM: $proposal_file"
    
    if ! "$covm_path" validate "$proposal_file" > /dev/null 2>&1; then
      log_error "Proposal validation failed with CoVM: $proposal_file"
      return 1
    fi
  else
    log_warn "CoVM binary not found, skipping deep validation"
  fi
  
  return 0
}

# Process a single proposal
process_proposal() {
  local proposal="$1"
  local proposal_id
  local proposal_title
  local proposal_content
  
  # Extract proposal information
  proposal_id=$(echo "$proposal" | jq -r '.id')
  proposal_title=$(echo "$proposal" | jq -r '.title')
  proposal_content=$(echo "$proposal" | jq -r '.content')
  
  log_info "Processing proposal: $proposal_id - $proposal_title"
  
  # Create DSL file in queue directory
  local dsl_file="${QUEUE_DIR}/proposal_${proposal_id}.dsl"
  
  # Check if the proposal already exists in queue
  if [[ -f "$dsl_file" ]]; then
    log_info "Proposal already in queue: $proposal_id"
    return 0
  fi
  
  # Write proposal content to DSL file
  echo "$proposal_content" > "$dsl_file"
  
  # Validate the proposal
  if validate_proposal "$dsl_file"; then
    log_success "Proposal validated and added to queue: $proposal_id"
    
    # Update proposal status in AgoraNet
    if [[ -n "$WEBHOOK_TOKEN" ]]; then
      local update_url="${AGORANET_API}/proposals/${proposal_id}/status"
      local update_status
      
      update_status=$(curl -s -X PUT \
        -H "Authorization: Bearer ${WEBHOOK_TOKEN}" \
        -H "Content-Type: application/json" \
        -d '{"status":"queued"}' \
        "$update_url")
      
      if [[ "$VERBOSE" == true ]]; then
        log_info "Status update response: $update_status"
      fi
    fi
  else
    log_error "Proposal validation failed, rejecting: $proposal_id"
    
    # Update proposal status in AgoraNet
    if [[ -n "$WEBHOOK_TOKEN" ]]; then
      local update_url="${AGORANET_API}/proposals/${proposal_id}/status"
      
      curl -s -X PUT \
        -H "Authorization: Bearer ${WEBHOOK_TOKEN}" \
        -H "Content-Type: application/json" \
        -d '{"status":"rejected", "reason":"Validation failed"}' \
        "$update_url" > /dev/null
    fi
    
    # Remove invalid proposal from queue
    rm -f "$dsl_file"
    return 1
  fi
  
  return 0
}

# Sync proposals from AgoraNet to local queue
sync_proposals() {
  log_info "Syncing proposals from AgoraNet to local queue"
  
  # Fetch pending proposals
  local proposals_json
  proposals_json=$(fetch_pending_proposals)
  
  if [[ $? -ne 0 ]]; then
    log_error "Failed to fetch proposals"
    return 1
  fi
  
  # Process each proposal
  local proposal_count
  proposal_count=$(echo "$proposals_json" | jq -r '.proposals | length')
  
  if [[ "$proposal_count" -eq 0 ]]; then
    log_info "No pending proposals found in AgoraNet"
    return 0
  fi
  
  log_info "Found $proposal_count pending proposals"
  
  local success_count=0
  for i in $(seq 0 $((proposal_count - 1))); do
    local proposal
    proposal=$(echo "$proposals_json" | jq -r ".proposals[$i]")
    
    if process_proposal "$proposal"; then
      success_count=$((success_count + 1))
    fi
  done
  
  log_info "Successfully processed $success_count of $proposal_count proposals"
  
  # Trigger proposal execution if we have the exec-covm.sh script
  if [[ -x "${SCRIPT_DIR}/exec-covm.sh" ]]; then
    if [[ "$success_count" -gt 0 ]]; then
      log_info "Triggering execution of queued proposals"
      "${SCRIPT_DIR}/exec-covm.sh" > /dev/null
    fi
  else
    log_warn "exec-covm.sh script not found, cannot trigger execution"
  fi
  
  return 0
}

# Main function for running the sync
run_sync() {
  if [[ "$SYNC_INTERVAL" -le 0 ]]; then
    # Run once
    sync_proposals
  else
    # Run continuously
    log_info "Starting continuous sync with interval of $SYNC_INTERVAL seconds"
    
    while true; do
      sync_proposals
      sleep "$SYNC_INTERVAL"
    done
  fi
}

main() {
  parse_args "$@"
  validate_args
  run_sync
}

main "$@" 
--- FILE: ./auto-node.sh ---
#!/bin/bash
set -euo pipefail

# ICN Auto Node
# A unified script that sets up and runs a fully autonomous ICN node

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Default values
NODE_TYPE="dev"
COOP_NAME="default"
AUTO_REGISTER=false
ENABLE_EVENTS=true
ENABLE_AGORANET=true
AUTO_UPDATE=false
VERBOSE=false

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Set up and run a fully autonomous ICN node with all features enabled.

Options:
  --node-type TYPE       Node type: 'dev', 'testnet', or 'livenet' (default: dev)
  --coop NAME            Cooperative name (default: default)
  --auto-register        Automatically register DNS and DID
  --no-events            Disable event monitoring
  --no-agoranet          Disable AgoraNet integration
  --auto-update          Enable automatic updates
  --verbose              Enable verbose logging
  --help                 Display this help message and exit

Example:
  $(basename "$0") --node-type testnet --coop "my-cooperative" --auto-register
EOF
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --node-type)
        NODE_TYPE="$2"
        shift 2
        ;;
      --coop)
        COOP_NAME="$2"
        shift 2
        ;;
      --auto-register)
        AUTO_REGISTER=true
        shift
        ;;
      --no-events)
        ENABLE_EVENTS=false
        shift
        ;;
      --no-agoranet)
        ENABLE_AGORANET=false
        shift
        ;;
      --auto-update)
        AUTO_UPDATE=true
        shift
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done
}

setup_auto_node() {
  log_info "Setting up autonomous ICN node"
  
  # 1. Check dependencies
  log_info "Checking dependencies..."
  check_dependencies || {
    log_error "Missing dependencies, please install them first"
    exit 1
  }
  
  # 2. Build/update node if needed or requested
  if [[ "$AUTO_UPDATE" == true ]] || ! is_binary_built "icn-node"; then
    log_info "Building/updating ICN node..."
    "${SCRIPT_DIR}/install.sh" --verbose || {
      log_error "Failed to build/update ICN node"
      exit 1
    }
  fi
  
  # 3. Start the daemon
  log_info "Starting ICN node daemon..."
  local daemon_cmd="${SCRIPT_DIR}/daemon.sh"
  daemon_cmd+=" --node-type ${NODE_TYPE}"
  [[ "$AUTO_REGISTER" == true ]] && daemon_cmd+=" --auto-register"
  [[ "$VERBOSE" == true ]] && daemon_cmd+=" --verbose"
  
  eval "$daemon_cmd" || {
    log_error "Failed to start ICN node daemon"
    exit 1
  }
  
  # 4. Wait for node to start
  log_info "Waiting for node to start..."
  local retries=0
  while ! is_node_running && [[ $retries -lt 30 ]]; do
    sleep 2
    retries=$((retries + 1))
  done
  
  if ! is_node_running; then
    log_error "Node failed to start within the timeout period"
    exit 1
  fi
  
  log_info "Node started successfully"
  
  # 5. Start event listener if enabled
  if [[ "$ENABLE_EVENTS" == true ]]; then
    log_info "Starting event listener..."
    local events_cmd="${SCRIPT_DIR}/event-listener.sh"
    events_cmd+=" --daemon"
    [[ "$VERBOSE" == true ]] && events_cmd+=" --verbose"
    
    eval "$events_cmd" || log_warn "Failed to start event listener"
  fi
  
  # 6. Start AgoraNet if enabled
  if [[ "$ENABLE_AGORANET" == true ]]; then
    log_info "Starting AgoraNet integration..."
    local agoranet_cmd="${SCRIPT_DIR}/agoranet-integration.sh"
    agoranet_cmd+=" --coop \"${COOP_NAME}\""
    agoranet_cmd+=" --daemon --start"
    [[ "$VERBOSE" == true ]] && agoranet_cmd+=" --verbose"
    
    eval "$agoranet_cmd" || log_warn "Failed to start AgoraNet integration"
  fi
  
  # 7. Display status
  log_info "Autonomous node setup complete!"
  get_node_status
  
  # 8. Display helpful information
  cat <<EOF

Your autonomous ICN node is now running!

Node type:    ${NODE_TYPE}
Cooperative:  ${COOP_NAME}
Events:       $(if [[ "$ENABLE_EVENTS" == true ]]; then echo "Enabled"; else echo "Disabled"; fi)
AgoraNet:     $(if [[ "$ENABLE_AGORANET" == true ]]; then echo "Enabled"; else echo "Disabled"; fi)

To view node logs:
  tail -f ~/.icn/logs/node.log

To stop the node:
  ${SCRIPT_DIR}/daemon.sh stop
  
To check node status:
  ${SCRIPT_DIR}/daemon.sh status

EOF
}

main() {
  parse_args "$@"
  setup_auto_node
}

main "$@" 
--- FILE: ./check-covm-status.sh ---
#!/bin/bash
set -e

# Check if deps/icn-covm exists
if [ ! -d "deps/icn-covm" ]; then
  echo "❌ Error: deps/icn-covm directory does not exist."
  echo "Please run ./scripts/install.sh first to set up dependencies."
  exit 1
fi

cd deps/icn-covm

if [ ! -d ".git" ]; then
  echo "❌ Error: deps/icn-covm is not a Git repository."
  echo "It may have been installed without Git history."
  exit 1
fi

echo "📍 CoVM Status:"
echo "Branch: $(git rev-parse --abbrev-ref HEAD)"
echo "Commit: $(git rev-parse HEAD)"

if ! git diff --quiet || ! git diff --cached --quiet; then
  echo "⚠️  Warning: You have uncommitted changes in icn-covm!"
  echo "🧠 Please commit them from inside deps/icn-covm to keep history clean."
  git status --short
else
  echo "✅ CoVM is clean."
fi

# Check if the commit hash is tracked in the parent repo
cd ../..
if [ -f ".covm-version" ]; then
  TRACKED_HASH=$(cat .covm-version)
  CURRENT_HASH=$(cd deps/icn-covm && git rev-parse HEAD)
  
  if [ "$TRACKED_HASH" = "$CURRENT_HASH" ]; then
    echo "✅ .covm-version matches current commit."
  else
    echo "⚠️  Warning: .covm-version ($TRACKED_HASH) differs from current commit ($CURRENT_HASH)."
    echo "Consider updating .covm-version with ./scripts/commit-covm.sh"
  fi
else
  echo "ℹ️  No .covm-version file found. Consider creating one to track the CoVM commit."
fi 
--- FILE: ./check-covm-version.sh ---
#!/bin/bash
set -e

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Path variables
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
DEV_NODE_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
COVM_DIR="$DEV_NODE_DIR/deps/icn-covm"
COVM_VERSION_FILE="$DEV_NODE_DIR/.covm-version"

# Helper function to print usage
usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --help       Display this help message"
    echo "  --quiet      Only output on error, useful for CI"
    echo "  --update     Update .covm-version to match the current repo"
    echo ""
    exit 1
}

# Parse arguments
QUIET=false
UPDATE=false
while [[ $# -gt 0 ]]; do
    case $1 in
        --help)
            usage
            ;;
        --quiet)
            QUIET=true
            shift
            ;;
        --update)
            UPDATE=true
            shift
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            usage
            ;;
    esac
done

# Ensure we're in the right directory
if [ ! -f "$DEV_NODE_DIR/Cargo.toml" ]; then
    echo -e "${RED}Error: Not running from the icn-dev-node repository${NC}"
    exit 1
fi

# Check if .covm-version exists
if [ ! -f "$COVM_VERSION_FILE" ]; then
    if [ "$QUIET" != "true" ]; then
        echo -e "${YELLOW}Warning: .covm-version file not found${NC}"
        echo "You should create this file to lock the CoVM version:"
        echo "  echo \$(cd ../icn-covm && git rev-parse HEAD) > .covm-version"
    fi
    exit 1
fi

# Check if deps/icn-covm exists
if [ ! -d "$COVM_DIR" ] || [ ! -d "$COVM_DIR/.git" ]; then
    if [ "$QUIET" != "true" ]; then
        echo -e "${RED}Error: CoVM not linked in deps/icn-covm${NC}"
        echo "Run the following command to set up CoVM:"
        echo "  make link-covm"
    fi
    exit 1
fi

# Get the expected version from .covm-version
EXPECTED_VERSION=$(cat "$COVM_VERSION_FILE")
if [ -z "$EXPECTED_VERSION" ]; then
    if [ "$QUIET" != "true" ]; then
        echo -e "${RED}Error: .covm-version file is empty${NC}"
    fi
    exit 1
fi

# Get the actual version from deps/icn-covm
cd "$COVM_DIR"
ACTUAL_VERSION=$(git rev-parse HEAD)

# Update .covm-version if requested
if [ "$UPDATE" = "true" ]; then
    if [ "$QUIET" != "true" ]; then
        echo -e "Updating .covm-version to ${GREEN}$ACTUAL_VERSION${NC}"
    fi
    echo "$ACTUAL_VERSION" > "$COVM_VERSION_FILE"
    exit 0
fi

# Compare versions
if [ "$EXPECTED_VERSION" = "$ACTUAL_VERSION" ]; then
    if [ "$QUIET" != "true" ]; then
        echo -e "${GREEN}✓ CoVM version matches .covm-version (${EXPECTED_VERSION:0:8})${NC}"
    fi
    exit 0
else
    if [ "$QUIET" != "true" ]; then
        echo -e "${RED}✗ CoVM version mismatch!${NC}"
        echo -e "Expected: ${YELLOW}$EXPECTED_VERSION${NC}"
        echo -e "Actual:   ${YELLOW}$ACTUAL_VERSION${NC}"
        echo ""
        echo "To fix this, either:"
        echo "  1. Run 'make link-covm' to update the linked CoVM"
        echo "  2. Update .covm-version with the current version:"
        echo "     echo \"$ACTUAL_VERSION\" > .covm-version"
    fi
    exit 1
fi 
--- FILE: ./commit-covm.sh ---
#!/bin/bash
set -euo pipefail

# Check if a commit message was provided
if [ $# -eq 0 ]; then
  echo "Usage: $0 \"Commit message\""
  echo "Example: $0 \"Add scoped identity enforcement\""
  exit 1
fi

MESSAGE="$1"
UPDATE_PARENT_REPO=${2:-"true"}  # Default to updating parent repo's .covm-version

# Check if deps/icn-covm exists
if [ ! -d "deps/icn-covm" ]; then
  echo "❌ Error: deps/icn-covm directory does not exist."
  echo "Please run ./scripts/install.sh first to set up dependencies."
  exit 1
fi

# Check if deps/icn-covm is a git repository
if [ ! -d "deps/icn-covm/.git" ]; then
  echo "❌ Error: deps/icn-covm is not a Git repository."
  exit 1
fi

# Commit changes in the CoVM repository
echo "📍 Committing changes to CoVM repository:"
cd deps/icn-covm

# Show what's going to be committed
git status --short

# Confirm with the user
read -p "Continue with commit? (y/n) " -n 1 -r
echo    # Move to a new line
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  echo "❌ Commit aborted."
  exit 1
fi

# Proceed with the commit
git add .
git commit -m "$MESSAGE"

# Get the new commit hash
COMMIT_HASH=$(git rev-parse HEAD)
echo "✅ Changes committed to CoVM repository. Commit hash: $COMMIT_HASH"

# Optionally push the changes
read -p "Push changes to remote repository? (y/n) " -n 1 -r
echo    # Move to a new line
if [[ $REPLY =~ ^[Yy]$ ]]; then
  git push
  echo "✅ Changes pushed to remote repository."
fi

# Update the parent repository's .covm-version file
if [ "$UPDATE_PARENT_REPO" = "true" ]; then
  cd ../..
  echo "$COMMIT_HASH" > .covm-version
  echo "✅ Updated .covm-version file in parent repository."
  
  # Ask if they want to commit the .covm-version file in the parent repo
  read -p "Commit .covm-version in parent repository? (y/n) " -n 1 -r
  echo    # Move to a new line
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    git add .covm-version
    git commit -m "Track CoVM commit: $COMMIT_HASH"
    echo "✅ Committed .covm-version in parent repository."
  else
    echo "ℹ️  .covm-version updated but not committed."
  fi
fi

echo "✅ All done!" 
--- FILE: ./common.sh ---
#!/bin/bash
# Common utility functions for ICN node scripts

# Log levels
LOG_LEVEL_ERROR=0
LOG_LEVEL_WARN=1
LOG_LEVEL_INFO=2
LOG_LEVEL_DEBUG=3

# Default log level
CURRENT_LOG_LEVEL=$LOG_LEVEL_INFO

# Set log level
set_log_level() {
  local level="${1:-info}"
  case "$level" in
    error) CURRENT_LOG_LEVEL=$LOG_LEVEL_ERROR ;;
    warn)  CURRENT_LOG_LEVEL=$LOG_LEVEL_WARN ;;
    info)  CURRENT_LOG_LEVEL=$LOG_LEVEL_INFO ;;
    debug) CURRENT_LOG_LEVEL=$LOG_LEVEL_DEBUG ;;
    *)
      echo "Unknown log level: $level. Using 'info'"
      CURRENT_LOG_LEVEL=$LOG_LEVEL_INFO
      ;;
  esac
}

# Logging functions
log_error() {
  if [[ $CURRENT_LOG_LEVEL -ge $LOG_LEVEL_ERROR ]]; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') [ERROR] $*" >&2
  fi
}

log_warn() {
  if [[ $CURRENT_LOG_LEVEL -ge $LOG_LEVEL_WARN ]]; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') [WARN] $*" >&2
  fi
}

log_info() {
  if [[ $CURRENT_LOG_LEVEL -ge $LOG_LEVEL_INFO ]]; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] $*"
  fi
}

log_debug() {
  if [[ $CURRENT_LOG_LEVEL -ge $LOG_LEVEL_DEBUG ]]; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') [DEBUG] $*"
  fi
}

# Check if a command is available
command_exists() {
  command -v "$1" >/dev/null 2>&1
}

# Check if running as root
is_root() {
  [[ $EUID -eq 0 ]]
}

# Get absolute path
get_abs_path() {
  local path="$1"
  if [[ -d "$path" ]]; then
    (cd "$path" && pwd)
  elif [[ -f "$path" ]]; then
    local dir
    dir=$(dirname "$path")
    local base
    base=$(basename "$path")
    echo "$(cd "$dir" && pwd)/$base"
  else
    echo "$path"
  fi
}

# Check if a port is in use
is_port_in_use() {
  local port="$1"
  if command_exists nc; then
    nc -z localhost "$port" >/dev/null 2>&1
    return $?
  elif command_exists lsof; then
    lsof -i:"$port" >/dev/null 2>&1
    return $?
  else
    # Fallback to /dev/tcp on bash
    (</dev/tcp/localhost/"$port") >/dev/null 2>&1
    return $?
  fi
}

# Find an available port starting from a base port
find_available_port() {
  local base_port="$1"
  local port="$base_port"
  
  while is_port_in_use "$port"; do
    port=$((port + 1))
  done
  
  echo "$port"
}

# Check if a node is running
is_node_running() {
  local port="${1:-26657}"  # Default RPC port
  
  if command_exists curl; then
    curl -s "http://localhost:$port/status" >/dev/null 2>&1
    return $?
  elif command_exists wget; then
    wget -q -O - "http://localhost:$port/status" >/dev/null 2>&1
    return $?
  else
    # Fallback to just checking if the port is in use
    is_port_in_use "$port"
    return $?
  fi
}

# Get node status information
get_node_status() {
  local port="${1:-26657}"  # Default RPC port
  local format="${2:-text}" # Output format: text, json
  
  if ! is_node_running "$port"; then
    log_error "Node is not running on port $port"
    return 1
  fi
  
  local status_url="http://localhost:$port/status"
  local status
  
  if command_exists curl; then
    status=$(curl -s "$status_url")
  elif command_exists wget; then
    status=$(wget -q -O - "$status_url")
  else
    log_error "Neither curl nor wget is available"
    return 1
  fi
  
  if [[ "$format" == "json" ]]; then
    echo "$status"
  else
    # Extract useful fields for text output
    if command_exists jq; then
      local node_info
      node_info=$(echo "$status" | jq -r '.result.node_info // empty')
      local latest_block_height
      latest_block_height=$(echo "$status" | jq -r '.result.sync_info.latest_block_height // "unknown"')
      
      if [[ -n "$node_info" ]]; then
        local id
        id=$(echo "$node_info" | jq -r '.id // "unknown"')
        local moniker
        moniker=$(echo "$node_info" | jq -r '.moniker // "unknown"')
        local network
        network=$(echo "$node_info" | jq -r '.network // "unknown"')
        
        echo "Node ID: $id"
        echo "Moniker: $moniker"
        echo "Network: $network"
        echo "Latest Block: $latest_block_height"
      else
        # Fallback to raw JSON if jq parsing fails
        echo "$status"
      fi
    else
      # Without jq, just return the raw JSON
      echo "$status"
    fi
  fi
}

# Check dependencies for the ICN node
check_dependencies() {
  local missing=0
  
  log_info "Checking dependencies..."
  
  # Required dependencies
  local deps=("git" "rustc" "cargo" "jq")
  
  for dep in "${deps[@]}"; do
    if ! command_exists "$dep"; then
      log_error "Missing dependency: $dep"
      missing=$((missing + 1))
    else
      log_debug "Found dependency: $dep"
    fi
  done
  
  # Platform-specific dependencies
  case "$(uname -s)" in
    Linux)
      if ! command_exists pkg-config; then
        log_error "Missing dependency: pkg-config"
        missing=$((missing + 1))
      fi
      
      # Check for libssl-dev by checking for openssl/ssl.h
      if ! pkg-config --exists openssl 2>/dev/null; then
        log_error "Missing dependency: libssl-dev"
        missing=$((missing + 1))
      fi
      ;;
    Darwin)
      if ! command_exists pkg-config; then
        log_error "Missing dependency: pkg-config"
        missing=$((missing + 1))
      fi
      
      if ! pkg-config --exists openssl 2>/dev/null; then
        log_error "Missing dependency: openssl"
        missing=$((missing + 1))
      fi
      ;;
    MINGW*|MSYS*|CYGWIN*)
      # Windows-specific checks
      log_warn "Running on Windows. Some features may not work as expected."
      ;;
  esac
  
  # Optional dependencies
  local opt_deps=("docker" "docker-compose")
  
  for dep in "${opt_deps[@]}"; do
    if ! command_exists "$dep"; then
      log_warn "Optional dependency not found: $dep"
    else
      log_debug "Found optional dependency: $dep"
    fi
  done
  
  if [[ $missing -gt 0 ]]; then
    log_warn "Missing $missing required dependencies"
    return 1
  else
    log_info "All required dependencies are installed"
    return 0
  fi
}

# Check if a specific binary is built
is_binary_built() {
  local binary_name="$1"
  local binary_path="${2:-${HOME}/.cargo/bin/$binary_name}"
  
  [[ -x "$binary_path" ]]
}

# Get a configuration value from TOML file
get_config_value() {
  local config_file="$1"
  local key="$2"
  local default="${3:-}"
  
  if [[ ! -f "$config_file" ]]; then
    echo "$default"
    return 1
  fi
  
  if command_exists jq && command_exists yq; then
    # Use yq to convert TOML to JSON, then jq to extract the value
    local value
    value=$(yq -p=toml -o=json eval "$config_file" | jq -r ".$key // empty")
    if [[ -n "$value" ]]; then
      echo "$value"
    else
      echo "$default"
    fi
  else
    # Fallback to grep/sed for simple keys
    local value
    value=$(grep -E "^$key\s*=\s*" "$config_file" | sed -E "s/^$key\s*=\s*//;s/\"//g")
    if [[ -n "$value" ]]; then
      echo "$value"
    else
      echo "$default"
    fi
  fi
}

# Export functions
export -f set_log_level
export -f log_error
export -f log_warn
export -f log_info
export -f log_debug
export -f command_exists
export -f is_root
export -f get_abs_path
export -f is_port_in_use
export -f find_available_port
export -f is_node_running
export -f get_node_status
export -f check_dependencies
export -f is_binary_built
export -f get_config_value 
--- FILE: ./daemon.sh ---
#!/bin/bash
set -euo pipefail

# ICN Node Daemon Script
# Runs an ICN node as a service with auto-join capability

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Default values
NODE_TYPE="dev"  # Options: dev, testnet, livenet
DATA_DIR="${HOME}/.icn"
NODE_NAME="icn-node-$(hostname)"
LOG_FILE="${DATA_DIR}/logs/node.log"
PID_FILE="${DATA_DIR}/node.pid"
COVM_PID_FILE="${DATA_DIR}/covm.pid"
CONFIG_FILE=""
BOOTSTRAP_PEERS=""
AUTO_REGISTER=false
FEDERATION=true
STORAGE=true
ENABLE_COVM=true  # Enable CoVM execution
COVM_WATCH_INTERVAL=60  # Check for new proposals every 60 seconds
VERBOSE=false
RESTART_DELAY=30
RUST_NODE=true  # Use Rust implementation by default

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Run the ICN node as a daemon service with auto-join capability.

Options:
  --node-type TYPE       Node type: 'dev', 'testnet', or 'livenet' (default: dev)
  --data-dir DIR         Data directory (default: ~/.icn)
  --node-name NAME       Node name (default: icn-node-HOSTNAME)
  --log-file FILE        Log file path (default: DATA_DIR/logs/node.log)
  --config FILE          Custom config file path
  --bootstrap-peers FILE Bootstrap peers file for testnet/livenet
  --auto-register        Automatically register DNS and DID
  --no-federation        Disable federation
  --no-storage           Disable storage
  --no-covm              Disable CoVM execution
  --covm-interval SEC    CoVM execution check interval in seconds (default: 60)
  --no-restart           Don't automatically restart on failure
  --no-rust-node         Use bash scripts instead of Rust implementation
  --verbose              Enable verbose logging
  --help                 Display this help message and exit

Example:
  $(basename "$0") --node-type testnet --auto-register
EOF
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --node-type)
        NODE_TYPE="$2"
        shift 2
        ;;
      --data-dir)
        DATA_DIR="$2"
        LOG_FILE="${DATA_DIR}/logs/node.log"
        PID_FILE="${DATA_DIR}/node.pid"
        COVM_PID_FILE="${DATA_DIR}/covm.pid"
        shift 2
        ;;
      --node-name)
        NODE_NAME="$2"
        shift 2
        ;;
      --log-file)
        LOG_FILE="$2"
        shift 2
        ;;
      --config)
        CONFIG_FILE="$2"
        shift 2
        ;;
      --bootstrap-peers)
        BOOTSTRAP_PEERS="$2"
        shift 2
        ;;
      --auto-register)
        AUTO_REGISTER=true
        shift
        ;;
      --no-federation)
        FEDERATION=false
        shift
        ;;
      --no-storage)
        STORAGE=false
        shift
        ;;
      --no-covm)
        ENABLE_COVM=false
        shift
        ;;
      --covm-interval)
        COVM_WATCH_INTERVAL="$2"
        shift 2
        ;;
      --no-restart)
        RESTART_DELAY=0
        shift
        ;;
      --no-rust-node)
        RUST_NODE=false
        shift
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done
}

validate_args() {
  if [[ ! "$NODE_TYPE" =~ ^(dev|testnet|livenet)$ ]]; then
    echo "Error: Node type must be 'dev', 'testnet', or 'livenet'"
    exit 1
  fi
  
  # Create necessary directories
  mkdir -p "$(dirname "$LOG_FILE")"
  mkdir -p "${DATA_DIR}/config"
  
  # Set default config file if not specified
  if [[ -z "$CONFIG_FILE" ]]; then
    case "$NODE_TYPE" in
      dev)
        CONFIG_FILE="${SCRIPT_DIR}/../config/dev-config.toml"
        ;;
      testnet)
        CONFIG_FILE="${SCRIPT_DIR}/../config/testnet-config.toml"
        ;;
      livenet)
        CONFIG_FILE="${SCRIPT_DIR}/../config/livenet-config.toml"
        ;;
    esac
  fi
  
  # Set default bootstrap peers file if not specified and needed
  if [[ -z "$BOOTSTRAP_PEERS" && "$NODE_TYPE" != "dev" ]]; then
    BOOTSTRAP_PEERS="${SCRIPT_DIR}/../config/bootstrap-peers.toml"
  fi
  
  # Validate files exist
  if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "Error: Config file not found: $CONFIG_FILE"
    exit 1
  fi
  
  if [[ "$NODE_TYPE" != "dev" && ! -f "$BOOTSTRAP_PEERS" ]]; then
    echo "Error: Bootstrap peers file not found: $BOOTSTRAP_PEERS"
    exit 1
  fi
}

start_node() {
  log_info "Starting ICN node in daemon mode..."
  
  # Build the run command based on node type
  local cmd
  if [[ "$NODE_TYPE" == "dev" ]]; then
    cmd="${SCRIPT_DIR}/run-node.sh"
    cmd+=" --node-name \"${NODE_NAME}\""
    cmd+=" --data-dir \"${DATA_DIR}\""
    
    # Add optional flags
    [[ "$FEDERATION" == false ]] && cmd+=" --no-federation"
    [[ "$STORAGE" == false ]] && cmd+=" --no-storage"
    [[ "$VERBOSE" == true ]] && cmd+=" --verbose"
  else
    cmd="${SCRIPT_DIR}/join-testnet.sh"
    [[ "$NODE_TYPE" == "livenet" ]] && cmd+=" --livenet"
    cmd+=" --node-name \"${NODE_NAME}\""
    cmd+=" --data-dir \"${DATA_DIR}\""
    cmd+=" --config \"${CONFIG_FILE}\""
    cmd+=" --bootstrap-peers \"${BOOTSTRAP_PEERS}\""
    
    # Add optional flags
    [[ "$FEDERATION" == false ]] && cmd+=" --no-federation"
    [[ "$STORAGE" == false ]] && cmd+=" --no-storage"
    [[ "$VERBOSE" == true ]] && cmd+=" --verbose"
  fi
  
  # Start the node as a background process
  log_info "Executing: $cmd"
  mkdir -p "$(dirname "$LOG_FILE")"
  
  # Create a wrapper script to ensure proper execution with eval
  local wrapper_script="${DATA_DIR}/node_wrapper.sh"
  cat > "$wrapper_script" <<EOF
#!/bin/bash
set -euo pipefail
exec $cmd
EOF
  chmod +x "$wrapper_script"
  
  # Run in background, redirecting output to log file
  nohup "$wrapper_script" > "$LOG_FILE" 2>&1 &
  echo $! > "$PID_FILE"
  
  log_info "Node started with PID $(cat "$PID_FILE")"
  
  # Register DNS and DID if requested
  if [[ "$AUTO_REGISTER" == true ]]; then
    log_info "Auto-registering DNS and DID entries..."
    # Wait a bit for the node to initialize
    sleep 5
    "${SCRIPT_DIR}/register-dns.sh" --node-name "$NODE_NAME" --coop "default" || \
      log_error "Failed to register DNS and DID entries"
  fi
  
  # Start CoVM execution if enabled
  if [[ "$ENABLE_COVM" == true ]]; then
    start_covm
  fi
}

# Start CoVM execution in watch mode
start_covm() {
  log_info "Starting CoVM execution in watch mode..."
  
  # Create queue directory if it doesn't exist
  mkdir -p "${DATA_DIR}/queue"
  
  if [[ "$RUST_NODE" == true ]]; then
    # Use Rust-based node runner
    log_info "Using Rust-based cooperative node runner"
    
    local covm_cmd="${SCRIPT_DIR}/icn-node-runner.sh"
    covm_cmd+=" run"
    covm_cmd+=" --data-dir \"${DATA_DIR}\""
    covm_cmd+=" --interval ${COVM_WATCH_INTERVAL}"
    [[ "$VERBOSE" == true ]] && covm_cmd+=" --verbose"
    
    # Create a wrapper script
    local covm_wrapper="${DATA_DIR}/covm_wrapper.sh"
    cat > "$covm_wrapper" <<EOF
#!/bin/bash
set -euo pipefail
exec $covm_cmd
EOF
    chmod +x "$covm_wrapper"
    
    # Start CoVM in background
    nohup "$covm_wrapper" > "${DATA_DIR}/logs/icn-node.log" 2>&1 &
    echo $! > "$COVM_PID_FILE"
    
    log_info "Rust node runner started with PID $(cat "$COVM_PID_FILE")"
    
  else
    # Use bash-based script
    log_info "Using bash-based cooperative node runner"
    
    # Build the CoVM execution command
    local covm_cmd="${SCRIPT_DIR}/exec-covm.sh"
    covm_cmd+=" --data-dir \"${DATA_DIR}\""
    covm_cmd+=" --watch"
    covm_cmd+=" --watch-interval ${COVM_WATCH_INTERVAL}"
    [[ "$VERBOSE" == true ]] && covm_cmd+=" --verbose"
    
    # Create a wrapper script for CoVM execution
    local covm_wrapper="${DATA_DIR}/covm_wrapper.sh"
    cat > "$covm_wrapper" <<EOF
#!/bin/bash
set -euo pipefail
exec $covm_cmd
EOF
    chmod +x "$covm_wrapper"
    
    # Start CoVM in background
    nohup "$covm_wrapper" > "${DATA_DIR}/logs/covm.log" 2>&1 &
    echo $! > "$COVM_PID_FILE"
    
    log_info "CoVM execution started with PID $(cat "$COVM_PID_FILE")"
  fi
}

stop_node() {
  # Stop CoVM execution first
  stop_covm
  
  # Then stop the node
  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid=$(cat "$PID_FILE")
    if ps -p "$pid" > /dev/null; then
      log_info "Stopping ICN node (PID: $pid)..."
      kill "$pid"
      # Wait for process to terminate
      for i in {1..30}; do
        if ! ps -p "$pid" > /dev/null; then
          break
        fi
        sleep 1
      done
      # Force kill if still running
      if ps -p "$pid" > /dev/null; then
        log_warn "Node did not terminate gracefully, force killing..."
        kill -9 "$pid" || true
      fi
    fi
    rm -f "$PID_FILE"
    log_info "Node stopped"
  else
    log_warn "No PID file found, node may not be running"
  fi
}

# Stop CoVM execution
stop_covm() {
  if [[ -f "$COVM_PID_FILE" ]]; then
    local covm_pid
    covm_pid=$(cat "$COVM_PID_FILE")
    if ps -p "$covm_pid" > /dev/null; then
      log_info "Stopping CoVM execution (PID: $covm_pid)..."
      kill "$covm_pid"
      # Wait for process to terminate
      for i in {1..10}; do
        if ! ps -p "$covm_pid" > /dev/null; then
          break
        fi
        sleep 1
      done
      # Force kill if still running
      if ps -p "$covm_pid" > /dev/null; then
        log_warn "CoVM did not terminate gracefully, force killing..."
        kill -9 "$covm_pid" || true
      fi
    fi
    rm -f "$COVM_PID_FILE"
    log_info "CoVM execution stopped"
  else
    log_debug "No CoVM PID file found"
  fi
}

check_node() {
  local node_running=false
  local covm_running=false
  
  # Check node status
  if [[ -f "$PID_FILE" ]]; then
    local pid
    pid=$(cat "$PID_FILE")
    if ps -p "$pid" > /dev/null; then
      log_info "ICN node is running (PID: $pid)"
      node_running=true
    else
      log_warn "Node PID file exists but process is not running"
      rm -f "$PID_FILE"
    fi
  else
    log_info "ICN node is not running"
  fi
  
  # Check CoVM status if enabled
  if [[ "$ENABLE_COVM" == true ]]; then
    if [[ -f "$COVM_PID_FILE" ]]; then
      local covm_pid
      covm_pid=$(cat "$COVM_PID_FILE")
      if ps -p "$covm_pid" > /dev/null; then
        log_info "CoVM execution is running (PID: $covm_pid)"
        covm_running=true
      else
        log_warn "CoVM PID file exists but process is not running"
        rm -f "$COVM_PID_FILE"
      fi
    else
      log_info "CoVM execution is not running"
    fi
  fi
  
  # Return success only if both are running (when CoVM is enabled)
  if [[ "$ENABLE_COVM" == true ]]; then
    [[ "$node_running" == true && "$covm_running" == true ]]
    return $?
  else
    [[ "$node_running" == true ]]
    return $?
  fi
}

monitor_node() {
  log_info "Starting node monitoring..."
  while true; do
    if ! check_node; then
      if [[ "$RESTART_DELAY" -gt 0 ]]; then
        log_warn "Node or CoVM is not running, restarting in $RESTART_DELAY seconds..."
        sleep "$RESTART_DELAY"
        stop_node || true  # Ensure everything is stopped
        start_node
      else
        log_info "Node or CoVM is not running, automatic restart disabled"
        break
      fi
    fi
    sleep 60
  done
}

main() {
  parse_args "$@"
  validate_args
  
  case "${1:-}" in
    start)
      stop_node || true  # Stop any existing instance
      start_node
      ;;
    stop)
      stop_node
      ;;
    restart)
      stop_node || true
      start_node
      ;;
    status)
      check_node
      ;;
    monitor)
      monitor_node
      ;;
    *)
      # Default: start and monitor
      stop_node || true
      start_node
      monitor_node
      ;;
  esac
}

main "$@" 
--- FILE: ./demo-proposals.sh ---
#!/usr/bin/env bash
set -euo pipefail

# Default settings
NO_START=false
DATA_DIR="$HOME/.icn-node"
AMOUNT="100token"
VOTING_PERIOD="30s"  # Short voting period for demo
SCOPED_IDENTITY=""
PROPOSAL_TYPE="Text"
SHOW_DAG_STATE=true

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --no-start)
      NO_START=true
      shift
      ;;
    --data-dir)
      DATA_DIR="$2"
      shift 2
      ;;
    --amount)
      AMOUNT="$2"
      shift 2
      ;;
    --voting-period)
      VOTING_PERIOD="$2"
      shift 2
      ;;
    --scoped-identity)
      SCOPED_IDENTITY="$2"
      shift 2
      ;;
    --proposal-type)
      PROPOSAL_TYPE="$2"
      shift 2
      ;;
    --no-dag)
      SHOW_DAG_STATE=false
      shift
      ;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--no-start] [--data-dir <dir>] [--amount <amount>] [--voting-period <period>] [--scoped-identity <identity>] [--proposal-type <type>] [--no-dag]"
      exit 1
      ;;
  esac
done

# Load environment variables if .env exists
if [[ -f ../.env ]]; then
  # shellcheck disable=SC1091
  source ../.env
fi

# Function to check if there's a running node
check_node_running() {
  if ! curl -s http://localhost:26657/status > /dev/null; then
    if [[ "$NO_START" = true ]]; then
      echo "❌ No node is running and --no-start was specified. Exiting."
      exit 1
    else
      echo "No node is running. Starting a local node..."
      ./run-node.sh --data-dir "$DATA_DIR" &
      NODE_PID=$!
      echo "Node started with PID $NODE_PID"
      echo "Waiting for node to start..."
      
      # Wait for node to start with timeout
      local max_attempts=30
      local attempts=0
      while ! curl -s http://localhost:26657/status > /dev/null && [[ $attempts -lt $max_attempts ]]; do
        sleep 1
        ((attempts++))
        echo -n "."
      done
      
      if [[ $attempts -ge $max_attempts ]]; then
        echo -e "\n❌ Timed out waiting for node to start"
        exit 1
      fi
      
      echo -e "\n✅ Node is running"
    fi
  else
    echo "✅ Node is running"
  fi
}

# Get validator address from node
get_validator_address() {
  local address
  if [[ -n "$SCOPED_IDENTITY" ]]; then
    echo "Using provided scoped identity: $SCOPED_IDENTITY"
    address="$SCOPED_IDENTITY"
  else
    echo "Getting validator address from the node..."
    address=$(curl -s http://localhost:26657/status | grep -o '"address":"[^"]*"' | head -1 | cut -d'"' -f4)
    if [[ -z "$address" ]]; then
      echo "❌ Could not get validator address from node"
      exit 1
    fi
    echo "Found validator address: $address"
  fi
  echo "$address"
}

# Create a governance proposal
create_proposal() {
  local title="Demo Proposal $(date +%s)"
  local description="This is a demonstration proposal created by the ICN dev node."
  local validator_address="$1"
  
  echo "Creating $PROPOSAL_TYPE proposal..."
  echo "  - Title: $title"
  echo "  - Description: $description"
  echo "  - Deposit: $AMOUNT"
  echo "  - Proposer: $validator_address"
  
  # Find the node binary
  local node_binary
  node_binary=$(find ../deps/icn-covm/target -name "icn-node" -type f -executable | head -1)
  
  if [[ -z "$node_binary" ]]; then
    echo "❌ Could not find node binary"
    exit 1
  fi
  
  # Submit the proposal using the CLI
  echo "Submitting proposal to the chain..."
  "$node_binary" tx gov submit-proposal \
    --title "$title" \
    --description "$description" \
    --type "$PROPOSAL_TYPE" \
    --deposit "$AMOUNT" \
    --from "$validator_address" \
    --home "$DATA_DIR" \
    --chain-id "icn-local" \
    --yes
  
  # Get the proposal ID
  echo "Fetching proposal ID..."
  local proposal_id=""
  local max_attempts=10
  local attempts=0
  
  while [[ -z "$proposal_id" ]] && [[ $attempts -lt $max_attempts ]]; do
    sleep 1
    proposal_id=$(curl -s http://localhost:26657/abci_query?path="\"/custom/gov/proposal_id\"" | 
                 grep -o '"value":"[^"]*"' | head -1 | cut -d'"' -f4 | 
                 base64 --decode 2>/dev/null || echo "")
    ((attempts++))
  done
  
  if [[ -z "$proposal_id" ]]; then
    echo "❌ Could not retrieve proposal ID after multiple attempts"
    exit 1
  fi
  
  echo "Proposal created with ID: $proposal_id"
  echo "Voting period: $VOTING_PERIOD"
  
  # Vote yes on the proposal
  echo "Voting yes on proposal..."
  "$node_binary" tx gov vote \
    "$proposal_id" "yes" \
    --from "$validator_address" \
    --home "$DATA_DIR" \
    --chain-id "icn-local" \
    --yes
  
  echo "✅ Demo proposal created and voted on successfully!"
  
  # Display DAG state if requested
  if [[ "$SHOW_DAG_STATE" = true ]]; then
    echo "🔍 Fetching DAG state for the proposal..."
    sleep 2  # Give some time for the vote to be processed
    
    echo "Latest DAG updates:"
    curl -s http://localhost:26657/dag_info | jq . || echo "⚠️ Could not fetch DAG info (jq not installed?)"
    
    echo "Proposal Details:"
    curl -s "http://localhost:26657/abci_query?path=\"/custom/gov/proposal/$proposal_id\"" | 
      jq '.result.response.value | @base64d | fromjson' 2>/dev/null || 
      echo "⚠️ Could not parse proposal details (jq not installed or proposal not found)"
  fi
  
  echo "You can check the proposal status with:"
  echo "curl http://localhost:26657/abci_query?path=\"/custom/gov/proposal/$proposal_id\""
}

# Main script execution
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$script_dir"

check_node_running
validator_address=$(get_validator_address)
create_proposal "$validator_address" 
--- FILE: ./dev-link-covm.sh ---
#!/bin/bash
set -e

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Parse command line arguments
FORCE=false
COVM_PATH=""

# Process arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -f|--force)
      FORCE=true
      shift
      ;;
    -p|--path)
      COVM_PATH="$2"
      shift 2
      ;;
    *)
      if [ -z "$COVM_PATH" ] && [ -d "$1" ]; then
        COVM_PATH="$1"
      fi
      shift
      ;;
  esac
done

# Paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
DEV_NODE_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
DEPS_DIR="$DEV_NODE_DIR/deps"
LINK_TARGET="$DEPS_DIR/icn-covm"
COVM_VERSION_FILE="$DEV_NODE_DIR/.covm-version"

# Check for icn-covm repo in various possible locations if not provided
if [ -z "$COVM_PATH" ]; then
  POSSIBLE_LOCATIONS=(
    "$DEV_NODE_DIR/../icn-covm"
    "$(cd ~ && pwd)/dev/icn-covm"
    "$(cd ~ && pwd)/icn-covm"
  )

  for loc in "${POSSIBLE_LOCATIONS[@]}"; do
    if [ -d "$loc" ] && [ -d "$loc/.git" ]; then
      COVM_PATH="$loc"
      break
    fi
  done
fi

# Verify the path exists and is a git repo
if [ -z "$COVM_PATH" ] || [ ! -d "$COVM_PATH" ] || [ ! -d "$COVM_PATH/.git" ]; then
  echo -e "${RED}Error: Could not find a valid icn-covm repository.${NC}"
  echo "Please provide the path to the icn-covm repository using the -p option:"
  echo "  $0 -p /path/to/icn-covm"
  echo ""
  echo "Searched locations:"
  for loc in "${POSSIBLE_LOCATIONS[@]}"; do
    echo "  - $loc"
  done
  exit 1
fi

echo -e "${GREEN}Found icn-covm repository at:${NC} $COVM_PATH"

# Check if both repos are clean (skipped if force is true)
if [ "$FORCE" != "true" ]; then
  echo "Checking repository status..."

  # Check dev-node status
  cd "$DEV_NODE_DIR"
  if [ -n "$(git status --porcelain)" ]; then
    echo -e "${YELLOW}Warning: icn-dev-node repository has uncommitted changes.${NC}"
    echo "Use --force to ignore uncommitted changes."
    exit 1
  fi

  # Check covm status
  cd "$COVM_PATH"
  if [ -n "$(git status --porcelain)" ]; then
    echo -e "${YELLOW}Warning: icn-covm repository has uncommitted changes.${NC}"
    echo "Use --force to ignore uncommitted changes."
    exit 1
  fi
fi

# Get current covm commit hash
cd "$COVM_PATH"
CURRENT_COVM_COMMIT=$(git rev-parse HEAD)

# Get back to dev-node directory
cd "$DEV_NODE_DIR"

# Check if .covm-version exists and compare
if [ -f "$COVM_VERSION_FILE" ]; then
  VERSION_COMMIT=$(cat "$COVM_VERSION_FILE")
  if [ "$VERSION_COMMIT" != "$CURRENT_COVM_COMMIT" ]; then
    echo -e "${YELLOW}⚠️ Warning: Local CoVM commit does not match .covm-version.${NC}"
    echo "Current commit: $CURRENT_COVM_COMMIT"
    echo "Version file:   $VERSION_COMMIT"
  else
    echo -e "${GREEN}CoVM commit matches .covm-version file.${NC}"
  fi
fi

# Remove existing directory or symlink if it exists
if [ -e "$LINK_TARGET" ]; then
  echo "Removing existing icn-covm in deps directory..."
  rm -rf "$LINK_TARGET"
fi

# Create deps directory if it doesn't exist
mkdir -p "$DEPS_DIR"

# Create the symlink
echo "Creating symlink to icn-covm repository..."
ln -s "$COVM_PATH" "$LINK_TARGET"

# Check if link creation was successful
if [ -L "$LINK_TARGET" ] && [ -e "$LINK_TARGET" ]; then
  echo -e "${GREEN}✓ Successfully linked CoVM for development!${NC}"
  echo -e "Changes made to ${YELLOW}$COVM_PATH${NC} will be immediately available in ${YELLOW}$DEV_NODE_DIR${NC}"
  echo ""
  echo -e "To build and test with your linked CoVM, run: ${GREEN}cargo build${NC} or ${GREEN}cargo test${NC}"
else
  echo -e "${RED}Failed to create symlink!${NC}"
  exit 1
fi

echo -e "${GREEN}Setup complete!${NC}" 
--- FILE: ./dump-code.sh ---
#!/bin/bash
set -euo pipefail

# Default file names
OUT_FILE="icn-dev-node_dump.txt"
TMP_FILE=".tmp_icn_dump.txt"
INCLUDE_DEPS=false
EXCLUDE_PATTERNS=(
  "./.git/*"
  "./target/*"
  "./node_modules/*"
  "./deps/*"         # Exclude all content in deps by default
  "./.cursor/*"      # Exclude cursor IDE files
  "./.wallet/*"      # Exclude wallet data
)
INCLUDE_REPOS=()

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --out)
      OUT_FILE="$2"
      shift 2
      ;;
    --include-deps)
      INCLUDE_DEPS=true
      shift
      ;;
    --exclude)
      EXCLUDE_PATTERNS+=("$2")
      shift 2
      ;;
    --include-repo)
      INCLUDE_REPOS+=("$2")
      shift 2
      ;;
    --help)
      echo "Usage: $0 [options]"
      echo "Options:"
      echo "  --out FILE              Output file name (default: icn-dev-node_dump.txt)"
      echo "  --include-deps          Include repositories from deps/ directory"
      echo "  --exclude PATTERN       Exclude files matching pattern (can be used multiple times)"
      echo "  --include-repo DIR      Include specific repository (requires --include-deps)"
      echo "  --help                  Show this help message"
      exit 0
      ;;
    *)
      echo "Unknown flag: $1"
      echo "Use --help for usage information"
      exit 1
      ;;
  esac
done

echo "🧵 Dumping repo to $OUT_FILE..."

# Write header
echo "# Code Dump for icn-dev-node" > "$TMP_FILE"
echo "# Generated on $(date)" >> "$TMP_FILE"
echo "# --------------------------------" >> "$TMP_FILE"

# Build exclude arguments for find
FIND_EXCLUDES=()
for pattern in "${EXCLUDE_PATTERNS[@]}"; do
  FIND_EXCLUDES+=(-not -path "$pattern")
done

# Main repo files
find . -type f \
  "${FIND_EXCLUDES[@]}" \
  ! -name "$TMP_FILE" \
  ! -name "$OUT_FILE" \
  | sort | while read -r file; do
    echo -e "\n--- FILE: $file ---" >> "$TMP_FILE"
    cat "$file" >> "$TMP_FILE"
done

# Optional dependency dump (only if explicitly enabled)
if [ "$INCLUDE_DEPS" = true ]; then
  echo -e "\n\n# --- DEP REPOS ---" >> "$TMP_FILE"
  
  # If specific repos were provided, only include those
  if [ ${#INCLUDE_REPOS[@]} -gt 0 ]; then
    for repo in "${INCLUDE_REPOS[@]}"; do
      if [ -d "$repo" ]; then
        echo -e "\n\n## Repo: $repo" >> "$TMP_FILE"
        find "$repo" -type f -not -path "*/\.*" | sort | while read -r f; do
          echo -e "\n--- FILE: $f ---" >> "$TMP_FILE"
          cat "$f" >> "$TMP_FILE"
        done
      fi
    done
  else
    # Include all repos in deps directory
    for dep in deps/*; do
      if [ -d "$dep" ] && [ ! -d "$dep/.git" ]; then
        # Skip git repositories unless explicitly included
        continue
      fi
      
      if [ -d "$dep" ]; then
        echo -e "\n\n## Repo: $dep" >> "$TMP_FILE"
        find "$dep" -type f -not -path "*/\.*" | sort | while read -r f; do
          echo -e "\n--- FILE: $f ---" >> "$TMP_FILE"
          cat "$f" >> "$TMP_FILE"
        done
      fi
    done
  fi
fi

# Rename temp file to final output
mv "$TMP_FILE" "$OUT_FILE"
echo "✅ Dump completed: $OUT_FILE"
echo "📏 File size: $(du -h "$OUT_FILE" | cut -f1)"

--- FILE: ./event-listener.sh ---
#!/bin/bash
set -euo pipefail

# ICN Node Event Listener
# Listens for events from the node and triggers actions based on them

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Default values
NODE_URL="http://localhost:26657"
EVENT_TYPES="tm.event='NewBlock'"
HOOKS_DIR="${HOME}/.icn/hooks"
LOG_FILE="${HOME}/.icn/logs/events.log"
MAX_RECONNECT_ATTEMPTS=10
RECONNECT_DELAY=5
RUN_AS_DAEMON=false

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Listen for events from an ICN node and trigger actions based on them.

Options:
  --node-url URL        Node RPC URL (default: http://localhost:26657)
  --events EVENTS       Event types to subscribe to (default: tm.event='NewBlock')
                        Multiple events can be specified with commas
  --hooks-dir DIR       Directory containing event hook scripts (default: ~/.icn/hooks)
  --log-file FILE       Log file path (default: ~/.icn/logs/events.log)
  --daemon              Run as a daemon in the background
  --max-reconnects N    Maximum reconnection attempts (default: 10, 0 for infinite)
  --reconnect-delay N   Delay between reconnection attempts in seconds (default: 5)
  --help                Display this help message and exit

Examples:
  # Listen for new blocks
  $(basename "$0") 
  
  # Listen for governance and federation events with custom hooks
  $(basename "$0") --events "tm.event='Tx' AND tx.type='governance',tm.event='Tx' AND tx.type='federation'" --hooks-dir "/path/to/hooks"
  
  # Run as a daemon with logging
  $(basename "$0") --daemon --log-file "/var/log/icn/events.log"
EOF
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --node-url)
        NODE_URL="$2"
        shift 2
        ;;
      --events)
        EVENT_TYPES="$2"
        shift 2
        ;;
      --hooks-dir)
        HOOKS_DIR="$2"
        shift 2
        ;;
      --log-file)
        LOG_FILE="$2"
        shift 2
        ;;
      --daemon)
        RUN_AS_DAEMON=true
        shift
        ;;
      --max-reconnects)
        MAX_RECONNECT_ATTEMPTS="$2"
        shift 2
        ;;
      --reconnect-delay)
        RECONNECT_DELAY="$2"
        shift 2
        ;;
      --help)
        print_usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done
}

validate_args() {
  # Create necessary directories
  mkdir -p "$HOOKS_DIR"
  mkdir -p "$(dirname "$LOG_FILE")"
  
  # Check if we can connect to the node
  if ! curl -s "$NODE_URL/status" >/dev/null; then
    log_error "Cannot connect to node at $NODE_URL"
    exit 1
  fi
}

# Function to handle events
handle_event() {
  local event="$1"
  local event_type
  local event_data
  
  # Extract event type and data
  if command_exists jq; then
    event_type=$(echo "$event" | jq -r '.result.query // "unknown"')
    event_data=$(echo "$event" | jq -r '.result.data // {}')
  else
    # Fallback if jq is not available
    event_type=$(echo "$event" | grep -o '"query":"[^"]*"' | sed 's/"query":"//;s/"//')
    event_data="$event"
  fi
  
  log_info "Received event of type: $event_type"
  log_debug "Event data: $event_data"
  
  # Look for hook scripts to execute
  for hook in "$HOOKS_DIR"/*; do
    if [[ -x "$hook" ]]; then
      log_debug "Executing hook: $hook"
      # Execute hook with event data
      "$hook" "$event_type" "$event_data" 2>&1 | tee -a "$LOG_FILE" || log_warn "Hook execution failed: $hook"
    fi
  done
}

# Function to subscribe to events
subscribe_to_events() {
  local reconnect_count=0
  
  while true; do
    log_info "Subscribing to events: $EVENT_TYPES"
    
    # Use curl to make a WebSocket connection
    if ! curl -s --no-buffer -N \
      -H "Connection: Upgrade" \
      -H "Upgrade: websocket" \
      -H "Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==" \
      -H "Sec-WebSocket-Version: 13" \
      "$NODE_URL/subscribe?query=$EVENT_TYPES" | while read -r line; do
        handle_event "$line"
      done; then
      
      reconnect_count=$((reconnect_count + 1))
      
      if [[ "$MAX_RECONNECT_ATTEMPTS" -gt 0 && "$reconnect_count" -ge "$MAX_RECONNECT_ATTEMPTS" ]]; then
        log_error "Failed to reconnect after $reconnect_count attempts, exiting."
        exit 1
      fi
      
      log_warn "Connection lost, reconnecting in $RECONNECT_DELAY seconds (attempt $reconnect_count)..."
      sleep "$RECONNECT_DELAY"
    fi
  done
}

run_as_daemon() {
  log_info "Starting event listener in daemon mode..."
  
  # Create a wrapper script
  local wrapper_script="/tmp/icn-event-listener-$$.sh"
  cat > "$wrapper_script" <<EOF
#!/bin/bash
set -euo pipefail
exec "$0" --node-url "$NODE_URL" --events "$EVENT_TYPES" --hooks-dir "$HOOKS_DIR" --log-file "$LOG_FILE" --max-reconnects "$MAX_RECONNECT_ATTEMPTS" --reconnect-delay "$RECONNECT_DELAY"
EOF
  chmod +x "$wrapper_script"
  
  # Start the process in the background
  nohup "$wrapper_script" > /dev/null 2>&1 &
  echo $! > "${HOME}/.icn/event-listener.pid"
  log_info "Event listener started in daemon mode with PID $(cat "${HOME}/.icn/event-listener.pid")"
}

create_default_hooks() {
  log_info "Creating default event hook examples in $HOOKS_DIR"
  
  # Create governance hook
  local gov_hook="${HOOKS_DIR}/governance-hook.sh"
  cat > "$gov_hook" <<EOF
#!/bin/bash
# Governance event hook for ICN node
set -euo pipefail

EVENT_TYPE="\$1"
EVENT_DATA="\$2"

echo "[$(date)] Received governance event: \$EVENT_TYPE"

# Process only governance-related events
if [[ "\$EVENT_TYPE" == *"governance"* ]]; then
  # Extract proposal ID and status (customize based on your event format)
  PROPOSAL_ID=\$(echo "\$EVENT_DATA" | jq -r '.proposal_id // empty')
  STATUS=\$(echo "\$EVENT_DATA" | jq -r '.status // empty')
  
  if [[ -n "\$PROPOSAL_ID" ]]; then
    echo "Processing governance proposal: \$PROPOSAL_ID (Status: \$STATUS)"
    
    # Example: If proposal passes, take some action
    if [[ "\$STATUS" == "passed" ]]; then
      echo "Proposal passed! Executing proposal actions..."
      # Add your custom actions here
    fi
  fi
fi
EOF
  chmod +x "$gov_hook"
  
  # Create federation hook
  local fed_hook="${HOOKS_DIR}/federation-hook.sh"
  cat > "$fed_hook" <<EOF
#!/bin/bash
# Federation event hook for ICN node
set -euo pipefail

EVENT_TYPE="\$1"
EVENT_DATA="\$2"

echo "[$(date)] Received federation event: \$EVENT_TYPE"

# Process only federation-related events
if [[ "\$EVENT_TYPE" == *"federation"* ]]; then
  # Extract peer ID and action (customize based on your event format)
  PEER_ID=\$(echo "\$EVENT_DATA" | jq -r '.peer_id // empty')
  ACTION=\$(echo "\$EVENT_DATA" | jq -r '.action // empty')
  
  if [[ -n "\$PEER_ID" && -n "\$ACTION" ]]; then
    echo "Federation event: Peer \$PEER_ID, Action: \$ACTION"
    
    # Example: If a new peer joins, update your peer list
    if [[ "\$ACTION" == "joined" ]]; then
      echo "New peer joined the federation: \$PEER_ID"
      # Add your custom actions here
    fi
  fi
fi
EOF
  chmod +x "$fed_hook"
  
  # Create DAG event hook
  local dag_hook="${HOOKS_DIR}/dag-hook.sh"
  cat > "$dag_hook" <<EOF
#!/bin/bash
# DAG state event hook for ICN node
set -euo pipefail

EVENT_TYPE="\$1"
EVENT_DATA="\$2"

echo "[$(date)] Received DAG event: \$EVENT_TYPE"

# Process only DAG-related events
if [[ "\$EVENT_TYPE" == *"NewBlock"* ]]; then
  # Extract block height and timestamp
  HEIGHT=\$(echo "\$EVENT_DATA" | jq -r '.block.header.height // empty')
  
  if [[ -n "\$HEIGHT" ]]; then
    echo "New block added to DAG: Height \$HEIGHT"
    
    # Example: Every 100 blocks, generate a DAG state report
    if [[ \$((HEIGHT % 100)) -eq 0 ]]; then
      echo "Generating DAG state report at height \$HEIGHT"
      # Add your custom actions here, e.g. call replay-dag.sh
    fi
  fi
fi
EOF
  chmod +x "$dag_hook"
  
  log_info "Default hooks created successfully"
}

main() {
  parse_args "$@"
  validate_args
  
  # Create default hooks if directory is empty
  if [[ -z "$(ls -A "$HOOKS_DIR" 2>/dev/null)" ]]; then
    create_default_hooks
  fi
  
  if [[ "$RUN_AS_DAEMON" == true ]]; then
    run_as_daemon
  else
    subscribe_to_events
  fi
}

main "$@" 
--- FILE: ./exec-covm.sh ---
#!/bin/bash
set -euo pipefail

# ICN CoVM Execution Script
# This script handles the execution of CoVM DSL files

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"
source "${SCRIPT_DIR}/node-state.sh" # For state tracking

# Default values
DATA_DIR="${HOME}/.icn"
COVM_BIN="${SCRIPT_DIR}/../deps/covm/bin/covm"
DSL_DIR="${DATA_DIR}/dsl"
QUEUE_DIR="${DATA_DIR}/queue"
OUTPUT_DIR="${DATA_DIR}/output"
LOG_FILE="${DATA_DIR}/logs/covm-exec.log"
PROPOSAL_ID=""
PROPOSAL_PATH=""
AUTO_APPROVE=false
VERBOSE=false
SHOW_OUTPUT=true

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS] [DSL_FILE]

Execute CoVM DSL files directly or from the proposal queue.

Options:
  --data-dir DIR        Data directory (default: ${DATA_DIR})
  --covm-bin PATH       Path to CoVM binary (default: ${COVM_BIN})
  --proposal ID         Execute a specific proposal by ID
  --auto-approve        Automatically approve proposals (default: ${AUTO_APPROVE})
  --no-output           Don't display execution output
  --verbose             Enable verbose logging
  --help                Display this help message and exit

Examples:
  # Execute a DSL file directly
  $(basename "$0") path/to/file.dsl
  
  # Execute a specific proposal
  $(basename "$0") --proposal 123
  
  # Execute the next queued proposal
  $(basename "$0")
EOF
}

parse_args() {
  DSL_FILE=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --data-dir)
        DATA_DIR="$2"
        DSL_DIR="${DATA_DIR}/dsl"
        QUEUE_DIR="${DATA_DIR}/queue"
        OUTPUT_DIR="${DATA_DIR}/output"
        LOG_FILE="${DATA_DIR}/logs/covm-exec.log"
        shift 2
        ;;
      --covm-bin)
        COVM_BIN="$2"
        shift 2
        ;;
      --proposal)
        PROPOSAL_ID="$2"
        shift 2
        ;;
      --auto-approve)
        AUTO_APPROVE=true
        shift
        ;;
      --no-output)
        SHOW_OUTPUT=false
        shift
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      -*)
        log_error "Unknown option: $1"
        print_usage
        exit 1
        ;;
      *)
        DSL_FILE="$1"
        shift
        ;;
    esac
  done
}

validate_args() {
  # Create necessary directories
  mkdir -p "$DSL_DIR" "$QUEUE_DIR" "$OUTPUT_DIR" "$(dirname "$LOG_FILE")"

  # Validate CoVM binary
  if [[ ! -x "$COVM_BIN" ]]; then
    log_error "CoVM binary not found or not executable: $COVM_BIN"
    log_info "You may need to install CoVM or specify a different path with --covm-bin"
    return 1
  fi

  # Determine what to execute
  if [[ -n "$DSL_FILE" ]]; then
    # Execute a specific DSL file
    if [[ ! -f "$DSL_FILE" ]]; then
      log_error "DSL file not found: $DSL_FILE"
      return 1
    fi
  elif [[ -n "$PROPOSAL_ID" ]]; then
    # Execute a specific proposal by ID
    PROPOSAL_PATH=$(find_proposal_by_id "$PROPOSAL_ID")
    if [[ -z "$PROPOSAL_PATH" ]]; then
      log_error "Proposal not found with ID: $PROPOSAL_ID"
      return 1
    fi
  else
    # Execute next queued proposal if any
    PROPOSAL_PATH=$(find_next_proposal)
    if [[ -z "$PROPOSAL_PATH" ]]; then
      log_warn "No pending proposals found in queue"
      return 0
    fi
    PROPOSAL_ID=$(extract_proposal_id "$PROPOSAL_PATH")
  fi

  return 0
}

find_proposal_by_id() {
  local id="$1"
  local proposal_file
  
  proposal_file=$(find "$QUEUE_DIR" -name "proposal_${id}_*.dsl" -type f 2>/dev/null | head -n 1)
  
  echo "$proposal_file"
}

find_next_proposal() {
  local next_proposal
  
  # Find the proposal with the lowest ID
  next_proposal=$(find "$QUEUE_DIR" -name "proposal_*_pending.dsl" -type f 2>/dev/null | sort | head -n 1)
  
  echo "$next_proposal"
}

extract_proposal_id() {
  local proposal_path="$1"
  local proposal_name
  
  proposal_name=$(basename "$proposal_path")
  
  # Extract ID from filename format "proposal_ID_STATUS.dsl"
  echo "$proposal_name" | sed -E 's/proposal_([0-9]+)_.*/\1/'
}

confirm_execution() {
  local file="$1"
  local id="${2:-unknown}"
  
  echo
  log_info "About to execute CoVM proposal:"
  echo "-------------------------------------"
  echo "File: $file"
  echo "ID: $id"
  echo "-------------------------------------"
  echo
  
  if [[ "$AUTO_APPROVE" == true ]]; then
    return 0
  fi
  
  read -r -p "Do you want to proceed with execution? [y/N] " response
  
  if [[ "${response,,}" =~ ^y(es)?$ ]]; then
    return 0
  else
    log_warn "Execution cancelled by user"
    return 1
  fi
}

execute_dsl() {
  local file="$1"
  local proposal_id="${2:-unknown}"
  local output_file="${OUTPUT_DIR}/execution_${proposal_id}_$(date +%Y%m%d_%H%M%S).json"
  local temp_output
  local status_code=0
  
  log_info "Executing DSL file: $file"
  log_info "Output will be saved to: $output_file"
  
  # Update status to executing
  if [[ -n "$PROPOSAL_ID" && -n "$PROPOSAL_PATH" ]]; then
    update_proposal_status "$PROPOSAL_PATH" "executing"
  fi
  
  # Create a temporary file for output
  temp_output=$(mktemp)
  
  # Execute CoVM with the DSL file
  if "$COVM_BIN" "$file" > "$temp_output" 2>&1; then
    status_code=0
    log_success "Execution completed successfully"
  else
    status_code=$?
    log_error "Execution failed with exit code: $status_code"
  fi
  
  # Save output to final location
  mkdir -p "$(dirname "$output_file")"
  cat > "$output_file" <<EOF
{
  "proposal_id": "$proposal_id",
  "timestamp": "$(date --iso-8601=seconds)",
  "status_code": $status_code,
  "output": $(cat "$temp_output" | jq -R -s '.')
}
EOF
  
  # Display output if requested
  if [[ "$SHOW_OUTPUT" == true ]]; then
    echo
    echo "CoVM Execution Output:"
    echo "-------------------------------------"
    cat "$temp_output"
    echo "-------------------------------------"
    echo
  fi
  
  # Clean up the temporary file
  rm -f "$temp_output"
  
  # Update proposal status based on execution result
  if [[ -n "$PROPOSAL_ID" && -n "$PROPOSAL_PATH" ]]; then
    if [[ $status_code -eq 0 ]]; then
      update_proposal_status "$PROPOSAL_PATH" "completed"
      record_execution "$PROPOSAL_ID" "success"
    else
      update_proposal_status "$PROPOSAL_PATH" "failed"
      record_execution "$PROPOSAL_ID" "failed"
    fi
  fi
  
  return $status_code
}

update_proposal_status() {
  local proposal_path="$1"
  local new_status="$2"
  local new_path
  
  # Rename the file with the new status
  new_path="${proposal_path/%_*\.dsl/_${new_status}.dsl}"
  
  if [[ "$proposal_path" != "$new_path" ]]; then
    mv "$proposal_path" "$new_path"
    log_info "Updated proposal status to: $new_status"
    
    # Return the new path
    echo "$new_path"
  else
    # Return the original path if no change
    echo "$proposal_path"
  fi
}

main() {
  parse_args "$@"
  
  if ! validate_args; then
    exit 1
  fi
  
  # Execute DSL file directly if specified
  if [[ -n "$DSL_FILE" ]]; then
    if confirm_execution "$DSL_FILE"; then
      execute_dsl "$DSL_FILE"
      exit $?
    else
      exit 0
    fi
  fi
  
  # Execute proposal if found
  if [[ -n "$PROPOSAL_PATH" ]]; then
    if confirm_execution "$PROPOSAL_PATH" "$PROPOSAL_ID"; then
      execute_dsl "$PROPOSAL_PATH" "$PROPOSAL_ID"
      exit $?
    else
      exit 0
    fi
  fi
  
  # If we got here, nothing was executed
  log_info "No execution performed"
  exit 0
}

main "$@" 
--- FILE: ./federation-check.sh ---
#!/bin/bash

# Federation Status Check and Diagnostics Tool
# This script helps validate federation connections and diagnose issues

set -e

# Default values
NODE_URL="http://localhost:26657"
BOOTSTRAP_PEERS_FILE="config/bootstrap-peers.toml"
VERBOSE=false
OUTPUT_FORMAT="human" # Options: human, json
TIMEOUT=3
CHECK_INTERVAL=0  # 0 means run once, >0 means monitor every N seconds
MIN_PEERS=2

# ANSI color codes
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Print header
echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}    ICN Federation Status Check       ${NC}"
echo -e "${BLUE}======================================${NC}"

# Function to show usage
show_usage() {
  echo "Usage: $0 [OPTIONS]"
  echo ""
  echo "Options:"
  echo "  --node-url URL       Node RPC URL to check (default: http://localhost:26657)"
  echo "  --peers FILE         Bootstrap peers file (default: config/bootstrap-peers.toml)"
  echo "  --min-peers N        Minimum required peers for healthy federation (default: 2)"
  echo "  --monitor N          Monitor mode: check every N seconds (default: run once)"
  echo "  --timeout N          Connection timeout in seconds (default: 3)"
  echo "  --json               Output results in JSON format"
  echo "  --verbose            Enable verbose logging"
  echo "  --help               Show this help message"
  echo ""
  echo "Examples:"
  echo "  $0 --node-url http://mynode:26657 --peers my-peers.toml"
  echo "  $0 --monitor 60 --min-peers 3      # Check every minute, require 3+ peers"
  exit 1
}

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --node-url)
      NODE_URL="$2"
      shift 2
      ;;
    --peers)
      BOOTSTRAP_PEERS_FILE="$2"
      shift 2
      ;;
    --min-peers)
      MIN_PEERS="$2"
      shift 2
      ;;
    --monitor)
      CHECK_INTERVAL="$2"
      shift 2
      ;;
    --timeout)
      TIMEOUT="$2"
      shift 2
      ;;
    --json)
      OUTPUT_FORMAT="json"
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --help)
      show_usage
      ;;
    *)
      echo -e "${RED}Unknown option: $1${NC}"
      show_usage
      ;;
  esac
done

# Check for required tools
if ! command -v curl &> /dev/null; then
  echo -e "${RED}Error: 'curl' is required but not found${NC}"
  exit 1
fi

if ! command -v jq &> /dev/null; then
  echo -e "${RED}Error: 'jq' is required but not found${NC}"
  exit 1
fi

# Function to check if the node is reachable
check_node_status() {
  if [[ "$VERBOSE" = true ]]; then
    echo -e "${BLUE}Checking node status at $NODE_URL...${NC}"
  fi
  
  if ! curl -s --max-time "$TIMEOUT" "$NODE_URL/status" > /dev/null; then
    if [[ "$OUTPUT_FORMAT" = "human" ]]; then
      echo -e "${RED}ERROR: Node is not reachable at $NODE_URL${NC}"
    else
      echo '{"status":"error","error":"Node not reachable","node_url":"'$NODE_URL'"}'
    fi
    return 1
  fi
  
  local status_response
  status_response=$(curl -s --max-time "$TIMEOUT" "$NODE_URL/status")
  
  # Extract node ID and moniker
  local node_id
  node_id=$(echo "$status_response" | jq -r '.result.node_info.id')
  
  local moniker
  moniker=$(echo "$status_response" | jq -r '.result.node_info.moniker')
  
  if [[ "$OUTPUT_FORMAT" = "human" ]]; then
    echo -e "${GREEN}Node is reachable:${NC}"
    echo -e "  ID: $node_id"
    echo -e "  Moniker: $moniker"
  else
    echo '{"status":"ok","node_id":"'$node_id'","moniker":"'$moniker'","node_url":"'$NODE_URL'"}'
  fi
  
  return 0
}

# Function to check net info and peers
check_federation_status() {
  if [[ "$VERBOSE" = true ]]; then
    echo -e "${BLUE}Checking federation status...${NC}"
  fi
  
  local net_info
  net_info=$(curl -s --max-time "$TIMEOUT" "$NODE_URL/net_info")
  
  # Extract peer count
  local peer_count
  peer_count=$(echo "$net_info" | jq -r '.result.n_peers')
  
  # Extract peer details
  local peers_json
  peers_json=$(echo "$net_info" | jq -r '.result.peers')
  
  # Check if we have minimum required peers
  local federation_health
  if [ "$peer_count" -ge "$MIN_PEERS" ]; then
    federation_health="healthy"
  else
    federation_health="unhealthy"
  fi
  
  if [[ "$OUTPUT_FORMAT" = "human" ]]; then
    if [ "$peer_count" -ge "$MIN_PEERS" ]; then
      echo -e "${GREEN}Federation status: HEALTHY${NC}"
    else
      echo -e "${RED}Federation status: UNHEALTHY${NC}"
      echo -e "${YELLOW}Connected to $peer_count peers, but minimum requirement is $MIN_PEERS${NC}"
    fi
    
    echo -e "Connected peers: $peer_count"
    
    # Show peer details
    if [ "$peer_count" -gt 0 ]; then
      echo -e "\nPeer details:"
      for ((i=0; i<peer_count; i++)); do
        local peer_id
        peer_id=$(echo "$peers_json" | jq -r ".[$i].node_info.id")
        
        local peer_moniker
        peer_moniker=$(echo "$peers_json" | jq -r ".[$i].node_info.moniker")
        
        local peer_addr
        peer_addr=$(echo "$peers_json" | jq -r ".[$i].remote_ip")
        
        echo -e "  $((i+1)). $peer_moniker ($peer_id) @ $peer_addr"
      done
    fi
  else
    # JSON output
    echo "$net_info" | jq '{
      status: "ok",
      federation_status: "'$federation_health'",
      peer_count: '$peer_count',
      min_peers_required: '$MIN_PEERS',
      peers: [.result.peers[] | {
        id: .node_info.id,
        moniker: .node_info.moniker,
        address: .remote_ip
      }]
    }'
  fi
}

# Function to check federation configuration
check_federation_config() {
  if [[ "$VERBOSE" = true ]]; then
    echo -e "${BLUE}Checking federation configuration...${NC}"
  fi
  
  # Check if bootstrap peers file exists
  if [[ ! -f "$BOOTSTRAP_PEERS_FILE" ]]; then
    if [[ "$OUTPUT_FORMAT" = "human" ]]; then
      echo -e "${RED}ERROR: Bootstrap peers file not found: $BOOTSTRAP_PEERS_FILE${NC}"
    else
      echo '{"status":"error","error":"Bootstrap peers file not found","file":"'$BOOTSTRAP_PEERS_FILE'"}'
    fi
    return 1
  fi
  
  # Read bootstrap peers
  local bootstrap_peers
  if grep -q "peers = " "$BOOTSTRAP_PEERS_FILE"; then
    # Handle array format
    bootstrap_peers=$(grep -A 10 "peers = \[" "$BOOTSTRAP_PEERS_FILE" | 
                      sed -n '/\[/,/\]/p' | 
                      grep -oE '"[^"]+"' | 
                      sed 's/"//g')
  else
    # Handle key-value format
    bootstrap_peers=$(grep "peer[0-9]* = " "$BOOTSTRAP_PEERS_FILE" | 
                      cut -d '"' -f 2)
  fi
  
  # Count bootstrap peers
  local bootstrap_peer_count
  bootstrap_peer_count=$(echo "$bootstrap_peers" | wc -l)
  
  if [[ "$OUTPUT_FORMAT" = "human" ]]; then
    echo -e "Bootstrap peers configuration from $BOOTSTRAP_PEERS_FILE:"
    echo -e "  Total configured peers: $bootstrap_peer_count"
    
    if [[ "$VERBOSE" = true ]]; then
      echo -e "\nPeer addresses:"
      echo "$bootstrap_peers" | while read -r peer; do
        echo -e "  - $peer"
      done
    fi
  else
    # Convert bootstrap peers to JSON array
    local peers_json
    peers_json="["
    first=true
    while read -r peer; do
      if [ "$first" = true ]; then
        first=false
      else
        peers_json="$peers_json,"
      fi
      peers_json="$peers_json\"$peer\""
    done <<< "$bootstrap_peers"
    peers_json="$peers_json]"
    
    echo "{\"status\":\"ok\",\"config_file\":\"$BOOTSTRAP_PEERS_FILE\",\"peer_count\":$bootstrap_peer_count,\"peers\":$peers_json}"
  fi
}

# Function to test connectivity to bootstrap peers
test_bootstrap_connectivity() {
  if [[ "$VERBOSE" = true ]]; then
    echo -e "${BLUE}Testing connectivity to bootstrap peers...${NC}"
  fi
  
  # Read bootstrap peers
  local bootstrap_peers
  if grep -q "peers = " "$BOOTSTRAP_PEERS_FILE"; then
    # Handle array format
    bootstrap_peers=$(grep -A 10 "peers = \[" "$BOOTSTRAP_PEERS_FILE" | 
                      sed -n '/\[/,/\]/p' | 
                      grep -oE '"[^"]+"' | 
                      sed 's/"//g')
  else
    # Handle key-value format
    bootstrap_peers=$(grep "peer[0-9]* = " "$BOOTSTRAP_PEERS_FILE" | 
                      cut -d '"' -f 2)
  fi
  
  local reachable_count=0
  local unreachable_count=0
  local reachable_peers=()
  local unreachable_peers=()
  
  if [[ "$OUTPUT_FORMAT" = "human" ]]; then
    echo -e "\nTesting connectivity to bootstrap peers:"
  fi
  
  # Test each peer
  while read -r peer; do
    # Extract node ID and address
    local node_id=${peer%%@*}
    local node_addr=${peer##*@}
    
    if [[ "$VERBOSE" = true && "$OUTPUT_FORMAT" = "human" ]]; then
      echo -e "  Testing $node_id @ $node_addr..."
    fi
    
    # Try to connect
    if curl -s --max-time "$TIMEOUT" "http://$node_addr/status" > /dev/null; then
      reachable_count=$((reachable_count + 1))
      reachable_peers+=("$peer")
      
      if [[ "$OUTPUT_FORMAT" = "human" ]]; then
        echo -e "  ${GREEN}✓ $peer is reachable${NC}"
      fi
    else
      unreachable_count=$((unreachable_count + 1))
      unreachable_peers+=("$peer")
      
      if [[ "$OUTPUT_FORMAT" = "human" ]]; then
        echo -e "  ${RED}✗ $peer is not reachable${NC}"
      fi
    fi
  done <<< "$bootstrap_peers"
  
  local total_peers=$((reachable_count + unreachable_count))
  
  if [[ "$OUTPUT_FORMAT" = "human" ]]; then
    echo -e "\nConnectivity summary:"
    echo -e "  Total peers: $total_peers"
    echo -e "  Reachable: $reachable_count"
    echo -e "  Unreachable: $unreachable_count"
    
    if [ "$reachable_count" -lt "$MIN_PEERS" ]; then
      echo -e "\n${RED}WARNING: Not enough reachable bootstrap peers!${NC}"
      echo -e "${YELLOW}Federation requires at least $MIN_PEERS connected peers.${NC}"
    elif [ "$reachable_count" -eq 0 ]; then
      echo -e "\n${RED}CRITICAL: No bootstrap peers are reachable!${NC}"
      echo -e "${YELLOW}Check your network connection and peer configurations.${NC}"
    fi
  else
    # Build JSON arrays for reachable and unreachable peers
    local reachable_json="["
    local unreachable_json="["
    
    local first=true
    for peer in "${reachable_peers[@]}"; do
      if [ "$first" = true ]; then
        first=false
      else
        reachable_json="$reachable_json,"
      fi
      reachable_json="$reachable_json\"$peer\""
    done
    reachable_json="$reachable_json]"
    
    first=true
    for peer in "${unreachable_peers[@]}"; do
      if [ "$first" = true ]; then
        first=false
      else
        unreachable_json="$unreachable_json,"
      fi
      unreachable_json="$unreachable_json\"$peer\""
    done
    unreachable_json="$unreachable_json]"
    
    echo "{\"status\":\"ok\",\"total_peers\":$total_peers,\"reachable_count\":$reachable_count,\"unreachable_count\":$unreachable_count,\"reachable\":$reachable_json,\"unreachable\":$unreachable_json}"
  fi
}

# Function to run all checks
run_federation_checks() {
  if [[ "$OUTPUT_FORMAT" = "human" ]]; then
    echo -e "\n${BLUE}Running federation status check at $(date)${NC}"
    echo -e "${BLUE}--------------------------------------${NC}\n"
  fi
  
  # Check if the node is running
  if ! check_node_status; then
    return 1
  fi
  
  echo ""
  
  # Check federation configuration
  check_federation_config
  
  echo ""
  
  # Test connectivity to bootstrap peers
  test_bootstrap_connectivity
  
  echo ""
  
  # Check federation status
  check_federation_status
  
  if [[ "$OUTPUT_FORMAT" = "human" ]]; then
    echo -e "\n${BLUE}--------------------------------------${NC}"
  fi
}

# Main execution
if [ "$CHECK_INTERVAL" -eq 0 ]; then
  # Run once
  run_federation_checks
else
  # Monitor mode
  if [[ "$OUTPUT_FORMAT" = "human" ]]; then
    echo -e "${BLUE}Federation monitoring mode enabled.${NC}"
    echo -e "${BLUE}Checking every $CHECK_INTERVAL seconds. Press Ctrl+C to stop.${NC}\n"
  fi
  
  while true; do
    run_federation_checks
    
    if [[ "$OUTPUT_FORMAT" = "human" ]]; then
      echo -e "${YELLOW}Next check in $CHECK_INTERVAL seconds...${NC}"
    fi
    
    sleep "$CHECK_INTERVAL"
  done
fi 
--- FILE: ./generate-identity.sh ---
#!/usr/bin/env bash
set -euo pipefail

# Default settings
IDENTITY_NAME="user-$(date +%s)"
COOP_NAME="default-coop"
ROLE="member"
OUTPUT_DIR="../.wallet/identities"
VERBOSE=false
RELEASE_MODE=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --name)
      IDENTITY_NAME="$2"
      shift 2
      ;;
    --coop)
      COOP_NAME="$2"
      shift 2
      ;;
    --role)
      ROLE="$2"
      if [[ ! "$ROLE" =~ ^(admin|member|observer)$ ]]; then
        echo "❌ Invalid role: $ROLE"
        echo "Valid roles: admin, member, observer"
        exit 1
      fi
      shift 2
      ;;
    --output)
      OUTPUT_DIR="$2"
      shift 2
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --release)
      RELEASE_MODE=true
      shift
      ;;
    --help)
      echo "Usage: $0 [options]"
      echo "Generate a scoped identity for ICN"
      echo ""
      echo "Options:"
      echo "  --name <name>       Identity name (default: user-timestamp)"
      echo "  --coop <coop>       Cooperative name (default: default-coop)"
      echo "  --role <role>       Identity role [admin|member|observer] (default: member)"
      echo "  --output <dir>      Output directory (default: ../.wallet/identities)"
      echo "  --verbose           Show detailed output"
      echo "  --release           Use release build of icn-node"
      echo "  --help              Show this help message"
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      echo "Run '$0 --help' for usage information"
      exit 1
      ;;
  esac
done

# Load environment variables if .env exists
if [[ -f ../.env ]]; then
  # shellcheck disable=SC1091
  source ../.env
fi

# Output directory setup
IDENTITY_DIR="$OUTPUT_DIR/$COOP_NAME"
IDENTITY_FILE="$IDENTITY_DIR/$IDENTITY_NAME.json"

# Function to check if the node binary exists
check_node_binary() {
  local binary_path
  if [[ "$RELEASE_MODE" = true ]]; then
    binary_path="../deps/icn-covm/target/release/icn-node"
  else
    binary_path="../deps/icn-covm/target/debug/icn-node"
  fi

  if [[ ! -f "$binary_path" ]]; then
    echo "❌ Node binary not found at $binary_path"
    echo "Please run install.sh first or check that the build completed successfully."
    exit 1
  fi

  echo "✅ Node binary found at $binary_path"
  NODE_BINARY="$binary_path"
}

# Create a scoped identity
generate_identity() {
  echo "Generating scoped identity..."
  echo "  - Identity: $IDENTITY_NAME"
  echo "  - Cooperative: $COOP_NAME"
  echo "  - Role: $ROLE"
  
  # Create output directory if it doesn't exist
  mkdir -p "$IDENTITY_DIR"
  
  # Check if identity already exists
  if [[ -f "$IDENTITY_FILE" ]]; then
    echo "⚠️ Identity already exists at $IDENTITY_FILE"
    read -p "Overwrite? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo "Exiting without overwriting."
      exit 0
    fi
  fi
  
  # Generate identity using icn-node CLI
  # This is a placeholder for the actual command - adjust based on actual CLI
  local create_output
  
  # Log the command if verbose
  if [[ "$VERBOSE" = true ]]; then
    echo "Executing: $NODE_BINARY identity create --name $IDENTITY_NAME --scope $COOP_NAME --role $ROLE --output $IDENTITY_FILE"
  fi
  
  # Example of calling the binary - replace with actual CLI command for identity creation
  create_output=$("$NODE_BINARY" identity create \
                  --name "$IDENTITY_NAME" \
                  --scope "$COOP_NAME" \
                  --role "$ROLE" \
                  --output "$IDENTITY_FILE" 2>&1) || {
    echo "❌ Failed to create identity"
    if [[ "$VERBOSE" = true ]]; then
      echo "Error: $create_output"
    fi
    exit 1
  }
  
  # Print result
  if [[ "$VERBOSE" = true ]]; then
    echo "$create_output"
  fi
  
  # Verify the identity was created
  if [[ -f "$IDENTITY_FILE" ]]; then
    echo "✅ Identity created successfully at $IDENTITY_FILE"
    
    # Display basic info from the identity file (assumes JSON format)
    if command -v jq >/dev/null 2>&1; then
      echo "Identity Info:"
      jq -r '. | {id, scope, role, created_at}' "$IDENTITY_FILE" 2>/dev/null || echo "Could not parse identity file"
    else
      echo "Install 'jq' to view identity details"
    fi
  else
    echo "❌ Identity file not found after creation"
    exit 1
  fi
}

# Main script execution
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$script_dir"

check_node_binary
generate_identity 
--- FILE: ./icn-node-runner.sh ---
#!/bin/bash
set -euo pipefail

# ICN Node Runner Wrapper Script
# This script is a wrapper around the Rust icn-node binary

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Log functions in case common.sh doesn't provide them
if ! declare -f log_success &> /dev/null; then
  log_success() {
    echo -e "\033[32m$(date '+%Y-%m-%d %H:%M:%S') [SUCCESS] $*\033[0m"
  }
fi

if ! declare -f log_warn &> /dev/null; then
  log_warn() {
    echo -e "\033[33m$(date '+%Y-%m-%d %H:%M:%S') [WARN] $*\033[0m"
  }
fi

if ! declare -f log_error &> /dev/null; then
  log_error() {
    echo -e "\033[31m$(date '+%Y-%m-%d %H:%M:%S') [ERROR] $*\033[0m" >&2
  }
fi

if ! declare -f log_info &> /dev/null; then
  log_info() {
    echo -e "\033[36m$(date '+%Y-%m-%d %H:%M:%S') [INFO] $*\033[0m"
  }
fi

# Default values
RUST_NODE_BIN="${SCRIPT_DIR}/../target/debug/icn-node"
DATA_DIR="${HOME}/.icn"
LOG_FILE="${DATA_DIR}/logs/icn-node.log"
PID_FILE="${DATA_DIR}/icn-node.pid"
CHECK_INTERVAL=30
RUN_MODE="daemon"
TRACE_PROPOSAL=""
EXECUTE_FILE=""
FORCE_EXECUTE=false
VERBOSE=false

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [COMMAND] [OPTIONS]

Run the Cooperative Node Runner for ICN.

Commands:
  run                   Run the node in daemon mode (default)
  execute FILE          Execute a specific proposal file
  trace PROPOSAL_ID     Trace a proposal execution
  watch                 Watch DAG and proposal queue

Options:
  --data-dir DIR        Data directory (default: ~/.icn)
  --interval SEC        Check interval in seconds (default: 30)
  --force               Force execution without validation
  --verbose             Enable verbose logging
  --help                Display this help message and exit

Examples:
  # Run in daemon mode
  $(basename "$0") run --interval 15
  
  # Execute a specific proposal
  $(basename "$0") execute path/to/proposal.dsl
  
  # Trace a proposal
  $(basename "$0") trace 123
EOF
}

parse_args() {
  # Parse command if present
  if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
    RUN_MODE="$1"
    shift
    
    # Parse additional command arguments
    case "$RUN_MODE" in
      execute)
        if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
          EXECUTE_FILE="$1"
          shift
        else
          log_error "Missing file argument for 'execute' command"
          print_usage
          exit 1
        fi
        ;;
      trace)
        if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
          TRACE_PROPOSAL="$1"
          shift
        else
          log_error "Missing proposal ID for 'trace' command"
          print_usage
          exit 1
        fi
        ;;
      run|watch)
        # No additional arguments needed
        ;;
      *)
        log_error "Unknown command: $RUN_MODE"
        print_usage
        exit 1
        ;;
    esac
  fi
  
  # Parse options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --data-dir)
        DATA_DIR="$2"
        LOG_FILE="${DATA_DIR}/logs/icn-node.log"
        PID_FILE="${DATA_DIR}/icn-node.pid"
        shift 2
        ;;
      --interval)
        CHECK_INTERVAL="$2"
        shift 2
        ;;
      --force)
        FORCE_EXECUTE=true
        shift
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      *)
        log_error "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done
}

validate_args() {
  # Check if rust binary exists and build if needed
  if [[ ! -x "$RUST_NODE_BIN" ]]; then
    log_info "Rust node binary not found, building..."
    
    if ! command -v cargo &> /dev/null; then
      log_error "Cargo not found. Please install Rust and Cargo."
      exit 1
    fi
    
    (
      cd "${SCRIPT_DIR}/.."
      cargo build --bin icn-node
    )
    
    if [[ ! -x "$RUST_NODE_BIN" ]]; then
      log_error "Failed to build Rust node binary"
      exit 1
    fi
  fi
  
  # Create necessary directories
  mkdir -p "$(dirname "$LOG_FILE")"
  mkdir -p "${DATA_DIR}/queue"
  mkdir -p "${DATA_DIR}/executed"
}

run_node() {
  log_info "Starting ICN node runner in $RUN_MODE mode"
  
  case "$RUN_MODE" in
    run)
      # Run as daemon
      local cmd="$RUST_NODE_BIN run --interval $CHECK_INTERVAL"
      [[ "$VERBOSE" == true ]] && cmd="$cmd --log-level debug"
      
      log_info "Executing: $cmd"
      
      if [[ -f "$PID_FILE" ]]; then
        local pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
          log_warn "Node already running with PID $pid"
          return 0
        else
          log_info "Removing stale PID file"
          rm -f "$PID_FILE"
        fi
      fi
      
      nohup "$RUST_NODE_BIN" run --interval "$CHECK_INTERVAL" \
        $([[ "$VERBOSE" == true ]] && echo "--log-level debug") \
        > "$LOG_FILE" 2>&1 &
      
      echo $! > "$PID_FILE"
      log_success "Node started with PID $(cat "$PID_FILE")"
      ;;
      
    execute)
      # Execute proposal file
      local cmd="$RUST_NODE_BIN execute --file \"$EXECUTE_FILE\""
      [[ "$FORCE_EXECUTE" == true ]] && cmd="$cmd --force"
      [[ "$VERBOSE" == true ]] && cmd="$cmd --log-level debug"
      
      log_info "Executing: $cmd"
      eval "$cmd"
      ;;
      
    trace)
      # Trace proposal
      local cmd="$RUST_NODE_BIN trace --proposal \"$TRACE_PROPOSAL\""
      [[ "$VERBOSE" == true ]] && cmd="$cmd --log-level debug"
      
      log_info "Executing: $cmd"
      eval "$cmd"
      ;;
      
    watch)
      # Watch DAG and queue
      local cmd="$RUST_NODE_BIN watch"
      [[ "$VERBOSE" == true ]] && cmd="$cmd --log-level debug"
      
      log_info "Executing: $cmd"
      eval "$cmd"
      ;;
  esac
}

stop_node() {
  if [[ -f "$PID_FILE" ]]; then
    local pid=$(cat "$PID_FILE")
    if kill -0 "$pid" 2>/dev/null; then
      log_info "Stopping ICN node with PID $pid"
      kill "$pid"
      rm -f "$PID_FILE"
      log_success "Node stopped"
    else
      log_info "No running node found"
      rm -f "$PID_FILE"
    fi
  else
    log_info "No PID file found, node not running"
  fi
}

# Main execution
parse_args "$@"
validate_args
run_node 
--- FILE: ./init-node.sh ---
#!/bin/bash

# ICN Node Initialization Script
# This script guides developers through initializing an ICN Dev Node

set -e

# ANSI color codes
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}    ICN Node Initialization Tool     ${NC}"
echo -e "${BLUE}======================================${NC}"
echo ""

# Ask for node type
echo -e "${YELLOW}Which type of node do you want to initialize?${NC}"
PS3="Select a node type: "
options=("Dev-Net" "Cooperative" "Community" "Federation")
select node_type in "${options[@]}"; do
  case $node_type in
    "Dev-Net")
      echo -e "${GREEN}Initializing Dev-Net node...${NC}"
      
      # Join test network
      echo -e "${YELLOW}Running join-testnet.sh...${NC}"
      read -p "Proceed? [Y/n] " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        ./scripts/join-testnet.sh
      else
        echo "Skipped joining test network."
      fi
      
      # Create test identities
      echo -e "${YELLOW}Would you like to create test scoped identities?${NC} [Yes/No]"
      read -r create_identities
      if [[ "$create_identities" =~ ^[Yy][Ee][Ss]$ ]] || [[ "$create_identities" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Running simulate-coop.sh...${NC}"
        read -p "Proceed? [Y/n] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
          ./scripts/simulate-coop.sh --coop "dev-net-test-coop" --identity-count 3 --replay
        else
          echo "Skipped creating test identities."
        fi
      fi
      break
      ;;
    
    "Cooperative")
      echo -e "${GREEN}Initializing Cooperative node...${NC}"
      
      # Get cooperative name
      echo -e "${YELLOW}Enter your cooperative name:${NC}"
      read -r COOP_NAME
      
      # Run node
      echo -e "${YELLOW}Running run-node.sh with name '$COOP_NAME'...${NC}"
      read -p "Proceed? [Y/n] " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        ./scripts/run-node.sh --node-name "$COOP_NAME"
      else
        echo "Skipped running node."
      fi
      
      # Generate admin identity
      echo -e "${YELLOW}Generating admin identity...${NC}"
      read -p "Proceed? [Y/n] " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        ./scripts/generate-identity.sh --name "admin" --coop "$COOP_NAME" --role "admin"
      else
        echo "Skipped generating admin identity."
      fi
      
      # Ask for additional identities
      echo -e "${YELLOW}Would you like to create additional identities?${NC} [Yes/No]"
      read -r create_more
      while [[ "$create_more" =~ ^[Yy][Ee][Ss]$ ]] || [[ "$create_more" =~ ^[Yy]$ ]]; do
        echo -e "${YELLOW}Enter identity name:${NC}"
        read -r ID_NAME
        echo -e "${YELLOW}Enter identity role:${NC}"
        read -r ID_ROLE
        
        echo -e "${YELLOW}Generating identity '$ID_NAME' with role '$ID_ROLE'...${NC}"
        read -p "Proceed? [Y/n] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
          ./scripts/generate-identity.sh --name "$ID_NAME" --coop "$COOP_NAME" --role "$ID_ROLE"
        else
          echo "Skipped generating identity."
        fi
        
        echo -e "${YELLOW}Create another identity?${NC} [Yes/No]"
        read -r create_more
      done
      break
      ;;
    
    "Community")
      echo -e "${GREEN}Initializing Community node...${NC}"
      
      # Get community name
      echo -e "${YELLOW}Enter your community name:${NC}"
      read -r COMMUNITY_NAME
      
      # Run node
      echo -e "${YELLOW}Running run-node.sh with name '$COMMUNITY_NAME' and no federation...${NC}"
      read -p "Proceed? [Y/n] " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        ./scripts/run-node.sh --node-name "$COMMUNITY_NAME" --no-federation
      else
        echo "Skipped running node."
      fi
      
      # Generate observer identity
      echo -e "${YELLOW}Generating observer identity...${NC}"
      read -p "Proceed? [Y/n] " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        ./scripts/generate-identity.sh --name "observer" --coop "$COMMUNITY_NAME" --role "observer"
      else
        echo "Skipped generating observer identity."
      fi
      
      # Ask for additional identities
      echo -e "${YELLOW}Would you like to create additional identities?${NC} [Yes/No]"
      read -r create_more
      while [[ "$create_more" =~ ^[Yy][Ee][Ss]$ ]] || [[ "$create_more" =~ ^[Yy]$ ]]; do
        echo -e "${YELLOW}Enter identity name:${NC}"
        read -r ID_NAME
        
        echo -e "${YELLOW}Generating identity '$ID_NAME' with observer role...${NC}"
        read -p "Proceed? [Y/n] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
          ./scripts/generate-identity.sh --name "$ID_NAME" --coop "$COMMUNITY_NAME" --role "observer"
        else
          echo "Skipped generating identity."
        fi
        
        echo -e "${YELLOW}Create another identity?${NC} [Yes/No]"
        read -r create_more
      done
      break
      ;;
    
    "Federation")
      echo -e "${GREEN}Initializing Federation node...${NC}"
      
      # Get federation name
      echo -e "${YELLOW}Enter federation group name:${NC}"
      read -r FEDERATION_NAME
      
      # Run node
      echo -e "${YELLOW}Running run-node.sh with federation enabled...${NC}"
      read -p "Proceed? [Y/n] " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        ./scripts/run-node.sh --node-name "$FEDERATION_NAME" --enable-federation
      else
        echo "Skipped running node."
      fi
      
      # Get peer multiaddresses
      echo -e "${YELLOW}Enter federation peer multiaddresses (comma-separated):${NC}"
      read -r PEER_ADDRESSES
      
      # Write peer addresses to bootstrap-peers.toml
      PEERS_FILE="config/bootstrap-peers.toml"
      echo -e "${YELLOW}Writing peer addresses to ${PEERS_FILE}...${NC}"
      
      # Create peers file with header
      cat > "$PEERS_FILE" << EOF
# Federation Bootstrap Peers
# Generated by init-node.sh on $(date)
# Federation: $FEDERATION_NAME

[peers]
EOF
      
      # Parse comma-separated addresses and add them to the file
      IFS=',' read -ra ADDR_ARRAY <<< "$PEER_ADDRESSES"
      for i in "${!ADDR_ARRAY[@]}"; do
        ADDR=$(echo "${ADDR_ARRAY[$i]}" | xargs)  # Trim whitespace
        echo "peer$((i+1)) = \"$ADDR\"" >> "$PEERS_FILE"
      done
      
      echo -e "${GREEN}Peer configuration written to ${PEERS_FILE}${NC}"
      echo -e "${YELLOW}Connecting to federation peers...${NC}"
      read -p "Proceed? [Y/n] " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        ./scripts/run-node.sh --node-name "$FEDERATION_NAME" --enable-federation --bootstrap-peers "$PEERS_FILE" --restart
      else
        echo "Skipped connecting to federation peers."
      fi
      
      # Generate federation admin identity
      echo -e "${YELLOW}Generating federation admin identity...${NC}"
      read -p "Proceed? [Y/n] " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
        ./scripts/generate-identity.sh --name "federation-admin" --coop "$FEDERATION_NAME" --role "admin"
      else
        echo "Skipped generating federation admin identity."
      fi

      # Check federation status
      echo -e "${YELLOW}Would you like to check federation connectivity?${NC} [Yes/No]"
      read -r check_federation
      if [[ "$check_federation" =~ ^[Yy][Ee][Ss]$ ]] || [[ "$check_federation" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Running federation status check...${NC}"
        read -p "Proceed? [Y/n] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
          ./scripts/federation-check.sh --peers "$PEERS_FILE" --verbose
        else
          echo "Skipped federation status check."
        fi
      fi

      break
      ;;
    
    *)
      echo "Invalid option. Please select 1, 2, 3, or 4."
      ;;
  esac
done

# AgoraNet Integration
echo -e "${YELLOW}Would you like to enable AgoraNet deliberation tools?${NC} [Yes/No]"
read -r enable_agora
if [[ "$enable_agora" =~ ^[Yy][Ee][Ss]$ ]] || [[ "$enable_agora" =~ ^[Yy]$ ]]; then
  echo -e "${YELLOW}Running AgoraNet service...${NC}"
  
  # Get cooperative name based on node type
  case $node_type in
    "Dev-Net")
      COOP_NAME="dev-net-test-coop"
      ;;
    "Cooperative")
      COOP_NAME="$COOP_NAME"
      ;;
    "Community")
      COOP_NAME="$COMMUNITY_NAME"
      ;;
    "Federation")
      COOP_NAME="$FEDERATION_NAME"
      ;;
  esac
  
  # Ask if it should run as a daemon
  echo -e "${YELLOW}Run AgoraNet as a background daemon?${NC} [Yes/No]"
  read -r run_daemon
  DAEMON_FLAG=""
  if [[ "$run_daemon" =~ ^[Yy][Ee][Ss]$ ]] || [[ "$run_daemon" =~ ^[Yy]$ ]]; then
    DAEMON_FLAG="--daemon"
  fi
  
  # Run the AgoraNet service
  read -p "Proceed? [Y/n] " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
    ./scripts/run-agoranet.sh --coop "$COOP_NAME" $DAEMON_FLAG
  else
    echo "Skipped running AgoraNet service."
  fi
else
  echo "Skipped enabling AgoraNet tools."
fi

# DNS and DID Registration
echo -e "${YELLOW}Would you like to register a DNS name and DID for your node?${NC} [Yes/No]"
read -r register_dns
if [[ "$register_dns" =~ ^[Yy][Ee][Ss]$ ]] || [[ "$register_dns" =~ ^[Yy]$ ]]; then
  echo -e "${YELLOW}Running DNS and DID registration...${NC}"
  
  # Get cooperative name based on node type
  case $node_type in
    "Dev-Net")
      COOP_NAME="dev-net-test-coop"
      ;;
    "Cooperative")
      COOP_NAME="$COOP_NAME"
      ;;
    "Community")
      COOP_NAME="$COMMUNITY_NAME"
      ;;
    "Federation")
      COOP_NAME="$FEDERATION_NAME"
      ;;
  esac
  
  # Run the DNS registration
  read -p "Proceed? [Y/n] " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
    ./scripts/register-dns.sh --coop "$COOP_NAME"
  else
    echo "Skipped DNS and DID registration."
  fi
else
  echo "Skipped DNS and DID registration."
fi

# Final verification
echo -e "${YELLOW}Verifying initialization by checking DAG state...${NC}"
read -p "Proceed? [Y/n] " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
  ./scripts/replay-dag.sh --json
else
  echo "Skipped final verification."
fi

# Print summary
echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}    ICN Node Initialization Summary   ${NC}"
echo -e "${BLUE}======================================${NC}"
echo -e "${GREEN}Node Type:${NC} $node_type"
case $node_type in
  "Dev-Net")
    echo -e "${GREEN}Environment:${NC} Test Network"
    ;;
  "Cooperative")
    echo -e "${GREEN}Cooperative Name:${NC} $COOP_NAME"
    ;;
  "Community")
    echo -e "${GREEN}Community Name:${NC} $COMMUNITY_NAME"
    ;;
  "Federation")
    echo -e "${GREEN}Federation Name:${NC} $FEDERATION_NAME"
    echo -e "${GREEN}Federation Peers:${NC} $PEER_ADDRESSES"
    ;;
esac

if [[ "$enable_agora" =~ ^[Yy][Ee][Ss]$ ]] || [[ "$enable_agora" =~ ^[Yy]$ ]]; then
  echo -e "${GREEN}AgoraNet Tools:${NC} Enabled"
  if [[ "$run_daemon" =~ ^[Yy][Ee][Ss]$ ]] || [[ "$run_daemon" =~ ^[Yy]$ ]]; then
    echo -e "${GREEN}AgoraNet Mode:${NC} Background Daemon"
  else
    echo -e "${GREEN}AgoraNet Mode:${NC} Interactive"
  fi
else
  echo -e "${GREEN}AgoraNet Tools:${NC} Disabled"
fi

if [[ "$register_dns" =~ ^[Yy][Ee][Ss]$ ]] || [[ "$register_dns" =~ ^[Yy]$ ]]; then
  # Determine the cooperative name based on node type for display
  case $node_type in
    "Dev-Net")
      DNS_COOP="dev-net-test-coop"
      ;;
    "Cooperative")
      DNS_COOP="$COOP_NAME"
      ;;
    "Community")
      DNS_COOP="$COMMUNITY_NAME"
      ;;
    "Federation")
      DNS_COOP="$FEDERATION_NAME"
      ;;
  esac
  
  echo -e "${GREEN}DNS Registration:${NC} Enabled"
  echo -e "${GREEN}DNS Name:${NC} ${DNS_COOP}.icn"
  echo -e "${GREEN}DID:${NC} did:icn:${DNS_COOP}"
else
  echo -e "${GREEN}DNS Registration:${NC} Disabled"
fi

echo -e "${BLUE}======================================${NC}"
echo -e "${GREEN}Initialization complete!${NC}"
echo -e "${YELLOW}For additional configuration options, check the documentation.${NC}" 
--- FILE: ./install.sh ---
#!/usr/bin/env bash
set -euo pipefail

# Default settings
SKIP_BUILD=false
RELEASE_BUILD=false
LOG_LEVEL="info"
DEPS_DIR="../deps"
CARGO_INSTALL=false
CLEAN_BUILD=false
SPECIFIC_REPO=""
UPDATE_VERSION_FILE=true

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --skip-build)
      SKIP_BUILD=true
      shift
      ;;
    --release)
      RELEASE_BUILD=true
      shift
      ;;
    --log-level)
      LOG_LEVEL="$2"
      shift 2
      ;;
    --cargo-install)
      CARGO_INSTALL=true
      shift
      ;;
    --clean)
      CLEAN_BUILD=true
      shift
      ;;
    --repo)
      SPECIFIC_REPO="$2"
      shift 2
      ;;
    --no-update-version)
      UPDATE_VERSION_FILE=false
      shift
      ;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--skip-build] [--release] [--log-level <level>] [--cargo-install] [--clean] [--repo <icn-covm|icn-agoranet|icn-wallet>] [--no-update-version]"
      exit 1
      ;;
  esac
done

# Function to check if a command exists
command_exists() {
  command -v "$1" >/dev/null 2>&1
}

# Check prerequisites
check_prerequisites() {
  local missing_deps=false

  echo "Checking prerequisites..."
  
  if ! command_exists git; then
    echo "❌ git is not installed"
    missing_deps=true
  fi

  if ! command_exists rustc; then
    echo "❌ Rust is not installed"
    missing_deps=true
  fi

  if ! command_exists cargo; then
    echo "❌ Cargo is not installed"
    missing_deps=true
  fi

  # Check for pkg-config and libssl-dev on Linux
  if [[ "$(uname)" == "Linux" ]]; then
    if ! command_exists pkg-config; then
      echo "⚠️ pkg-config is not installed (required for building)"
      echo "  Ubuntu/Debian: sudo apt-get install pkg-config"
      echo "  Fedora/RHEL: sudo dnf install pkgconf-pkg-config"
      missing_deps=true
    fi
    
    if ! ldconfig -p 2>/dev/null | grep -q libssl; then
      echo "⚠️ libssl development files not found (required for building)"
      echo "  Ubuntu/Debian: sudo apt-get install libssl-dev"
      echo "  Fedora/RHEL: sudo dnf install openssl-devel"
      missing_deps=true
    fi
  fi

  if [[ "$missing_deps" = true ]]; then
    echo "Please install missing dependencies and try again."
    echo "To install Rust: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh"
    exit 1
  fi

  echo "✅ All prerequisites met"
  
  # Check Rust version
  local rust_version
  rust_version=$(rustc --version | cut -d ' ' -f 2)
  echo "Rust version: $rust_version"
  
  # Check if Rust version is at least 1.60.0 (using basic string comparison)
  if [[ "$rust_version" < "1.60.0" ]]; then
    echo "⚠️ Recommended Rust version is 1.60.0 or higher"
    echo "Consider upgrading with: rustup update stable"
  fi
}

# Clone or update a repository
clone_or_update_repo() {
  local repo_url="$1"
  local target_dir="$2"
  local branch="${3:-main}"
  
  if [[ -d "$target_dir" ]]; then
    echo "Updating $target_dir..."
    (cd "$target_dir" && git fetch && git checkout "$branch" && git pull)
  else
    echo "Cloning $repo_url to $target_dir (branch: $branch)..."
    git clone --branch "$branch" "$repo_url" "$target_dir"
  fi
  
  # Record commit hash for icn-covm
  if [[ "$target_dir" == "icn-covm" && "$UPDATE_VERSION_FILE" == "true" ]]; then
    local commit_hash
    commit_hash=$(cd "$target_dir" && git rev-parse HEAD)
    echo "Recording CoVM commit hash: $commit_hash"
    cd "$(dirname "$DEPS_DIR")"
    echo "$commit_hash" > .covm-version
    cd - > /dev/null
  fi
}

# Build a repository
build_repo() {
  local repo_dir="$1"
  local repo_name="$2"
  
  echo "Building $repo_name..."
  cd "$repo_dir"
  
  # Clean if requested
  if [[ "$CLEAN_BUILD" = true ]]; then
    echo "Cleaning previous build..."
    cargo clean
  fi
  
  # Build with appropriate flags
  if [[ "$RELEASE_BUILD" = true ]]; then
    if [[ "$CARGO_INSTALL" = true ]]; then
      echo "Running cargo install --path . --force in release mode..."
      cargo install --path . --force
    else
      echo "Running cargo build --release..."
      cargo build --release
    fi
  else
    if [[ "$CARGO_INSTALL" = true ]]; then
      echo "Running cargo install --path . --force in debug mode..."
      cargo install --path . --force --debug
    else
      echo "Running cargo build..."
      cargo build
    fi
  fi
  
  echo "✅ $repo_name build completed!"
}

# Check and setup project dependencies
check_dependencies() {
  local repo_dir="$1"
  
  if [[ -f "$repo_dir/Cargo.toml" ]]; then
    echo "Checking dependencies for $(basename "$repo_dir")..."
    
    # Look for external dependencies that need to be installed
    if grep -q 'protoc' "$repo_dir/Cargo.toml"; then
      if ! command_exists protoc; then
        echo "⚠️ Protocol Buffers compiler (protoc) is required but not found"
        echo "  Ubuntu/Debian: sudo apt-get install protobuf-compiler"
        echo "  macOS: brew install protobuf"
        echo "  Or download from https://github.com/protocolbuffers/protobuf/releases"
        echo "Installation will continue, but build may fail"
      else
        echo "✅ Protocol Buffers compiler (protoc) found"
      fi
    fi
  fi
}

# Main installation function
install() {
  local script_dir
  script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  cd "$script_dir"
  
  # Create deps directory if it doesn't exist
  mkdir -p "$DEPS_DIR"
  cd "$DEPS_DIR"
  
  # Define repositories to handle
  declare -A repos=(
    ["icn-covm"]="https://github.com/interchainio/icn-covm.git"
    ["icn-agoranet"]="https://github.com/interchainio/icn-agoranet.git"
    ["icn-wallet"]="https://github.com/interchainio/icn-wallet.git"
  )
  
  # Process only specific repo if requested
  if [[ -n "$SPECIFIC_REPO" ]]; then
    if [[ -v "repos[$SPECIFIC_REPO]" ]]; then
      echo "Processing only the $SPECIFIC_REPO repository..."
      local filtered_repos=("$SPECIFIC_REPO")
    else
      echo "❌ Unknown repository: $SPECIFIC_REPO"
      echo "Valid repositories: ${!repos[*]}"
      exit 1
    fi
  else
    local filtered_repos=("${!repos[@]}")
  fi
  
  # Clone or update repos
  for repo in "${filtered_repos[@]}"; do
    clone_or_update_repo "${repos[$repo]}" "$repo"
  done
  
  # Build if not skipped
  if [[ "$SKIP_BUILD" = false ]]; then
    # Always build icn-covm if it's in the list
    if [[ -z "$SPECIFIC_REPO" ]] || [[ "$SPECIFIC_REPO" == "icn-covm" ]]; then
      check_dependencies "icn-covm"
      build_repo "icn-covm" "icn-covm"
    fi
    
    # Build other repos if specified
    if [[ "$SPECIFIC_REPO" == "icn-agoranet" ]]; then
      check_dependencies "icn-agoranet"
      build_repo "icn-agoranet" "icn-agoranet"
    elif [[ "$SPECIFIC_REPO" == "icn-wallet" ]]; then
      check_dependencies "icn-wallet"
      build_repo "icn-wallet" "icn-wallet"
    fi
  else
    echo "Skipping build as requested."
  fi
  
  echo "Installation completed successfully!"
  
  # Print information about the installed packages
  local build_type="debug"
  if [[ "$RELEASE_BUILD" = true ]]; then
    build_type="release"
  fi
  
  echo "===== Installation Summary ====="
  echo "ICN repositories installed in: $(cd "$DEPS_DIR" && pwd)"
  
  # Display CoVM version info
  cd "$(dirname "$DEPS_DIR")"
  if [[ -f ".covm-version" ]]; then
    echo "🔢 CoVM commit in use: $(cat .covm-version)"
  else
    echo "⚠️ No CoVM version tracked. Run './scripts/check-covm-status.sh' for details."
  fi
  
  if [[ "$SKIP_BUILD" = false ]]; then
    if [[ -z "$SPECIFIC_REPO" ]] || [[ "$SPECIFIC_REPO" == "icn-covm" ]]; then
      echo "ICN-COVM binary: $(cd "$DEPS_DIR" && pwd)/icn-covm/target/$build_type/icn-node"
    fi
  fi
  
  echo "To run the node: ./run-node.sh"
}

# Main script execution
check_prerequisites
install 
--- FILE: ./join-testnet.sh ---
#!/usr/bin/env bash
set -euo pipefail

# Default settings
RELEASE_MODE=false
LOG_LEVEL="info"
NODE_NAME="testnet-node-$(date +%s)"
DATA_DIR="$HOME/.icn-testnet"
CONFIG_FILE="../config/testnet-config.toml"
BOOTSTRAP_PEERS_FILE="../config/bootstrap-peers.toml"
VALIDATE_PEERS=true
RETRY_COUNT=3

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --release)
      RELEASE_MODE=true
      shift
      ;;
    --log-level)
      LOG_LEVEL="$2"
      shift 2
      ;;
    --node-name)
      NODE_NAME="$2"
      shift 2
      ;;
    --data-dir)
      DATA_DIR="$2"
      shift 2
      ;;
    --config)
      CONFIG_FILE="$2"
      shift 2
      ;;
    --bootstrap-peers)
      BOOTSTRAP_PEERS_FILE="$2"
      shift 2
      ;;
    --no-validate-peers)
      VALIDATE_PEERS=false
      shift
      ;;
    --retry)
      RETRY_COUNT="$2"
      shift 2
      ;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--release] [--log-level <level>] [--node-name <name>] [--data-dir <dir>] [--config <file>] [--bootstrap-peers <file>] [--no-validate-peers] [--retry <count>]"
      exit 1
      ;;
  esac
done

# Load environment variables if .env exists
if [[ -f ../.env ]]; then
  # shellcheck disable=SC1091
  source ../.env
fi

# Function to check if the node binary exists
check_node_binary() {
  local binary_path
  if [[ "$RELEASE_MODE" = true ]]; then
    binary_path="../deps/icn-covm/target/release/icn-node"
  else
    binary_path="../deps/icn-covm/target/debug/icn-node"
  fi

  if [[ ! -f "$binary_path" ]]; then
    echo "❌ Node binary not found at $binary_path"
    echo "Please run install.sh first or check that the build completed successfully."
    exit 1
  fi

  echo "✅ Node binary found at $binary_path"
  echo "NODE_BINARY=$binary_path"
  export NODE_BINARY="$binary_path"
}

# Create data directory if it doesn't exist
create_data_dir() {
  if [[ ! -d "$DATA_DIR" ]]; then
    echo "Creating data directory at $DATA_DIR..."
    mkdir -p "$DATA_DIR"
  fi
}

# Initialize the node if needed
init_node() {
  if [[ ! -d "$DATA_DIR/config" ]]; then
    echo "Initializing node with name '$NODE_NAME'..."
    "$NODE_BINARY" init --home "$DATA_DIR" --moniker "$NODE_NAME"
    
    # Apply testnet configuration if config file exists
    if [[ -f "$CONFIG_FILE" ]]; then
      echo "Applying testnet configuration from $CONFIG_FILE..."
      cp "$CONFIG_FILE" "$DATA_DIR/config/config.toml"
    else
      echo "⚠️ Testnet configuration file not found at $CONFIG_FILE"
      echo "Will use default configuration, but peer connections may not work correctly."
    fi
  else
    echo "Node already initialized at $DATA_DIR"
    
    # Update testnet configuration if requested
    if [[ -f "$CONFIG_FILE" ]]; then
      echo "Updating testnet configuration from $CONFIG_FILE..."
      cp "$CONFIG_FILE" "$DATA_DIR/config/config.toml"
    fi
  fi
}

# Parse the bootstrap peers from the TOML file
parse_bootstrap_peers() {
  local peers_file="$1"
  
  if [[ ! -f "$peers_file" ]]; then
    echo "⚠️ Bootstrap peers file not found at $peers_file"
    return 1
  fi
  
  # Extract peers from bootstrap-peers.toml using grep and sed
  # This is a basic parser for TOML arrays; for more complex TOML parsing, consider using a dedicated tool
  local peers
  peers=$(grep -A 10 '^\[bootstrap\]' "$peers_file" | grep -o 'peers = \[.*\]' | sed 's/peers = \[\(.*\)\]/\1/' | tr -d ' "')
  
  # Split the comma-separated list
  local IFS=','
  read -ra PEERS_ARRAY <<< "$peers"
  
  # Join with commas for the output format
  local joined_peers
  joined_peers=$(IFS=,; echo "${PEERS_ARRAY[*]}")
  
  echo "$joined_peers"
}

# Validate if peers are reachable
validate_peers() {
  local peer_list="$1"
  local validated_peers=()
  local success_count=0
  
  echo "Validating bootstrap peers..."
  
  # Split the peer list by commas
  IFS=',' read -ra PEER_ARRAY <<< "$peer_list"
  
  for peer in "${PEER_ARRAY[@]}"; do
    # Extract host and port from peer (format: node_id@host:port)
    local host
    local port
    host=$(echo "$peer" | cut -d '@' -f2 | cut -d ':' -f1)
    port=$(echo "$peer" | cut -d ':' -f2)
    
    echo -n "  - Testing connection to $host:$port... "
    
    # Try to establish a TCP connection to check if the peer is reachable
    if timeout 5 bash -c "exec 3<>/dev/tcp/$host/$port" 2>/dev/null; then
      echo "✅ Success"
      validated_peers+=("$peer")
      ((success_count++))
    else
      echo "❌ Failed"
    fi
    
    # Close the file descriptor if it was opened
    exec 3>&- 2>/dev/null || true
  done
  
  if [[ ${#validated_peers[@]} -eq 0 ]]; then
    echo "❌ No reachable bootstrap peers found!"
    return 1
  fi
  
  echo "✅ Found $success_count reachable bootstrap peers"
  
  # Join the validated peers with commas
  local result
  result=$(IFS=,; echo "${validated_peers[*]}")
  echo "$result"
}

# Get bootstrap peers from multiple sources
get_bootstrap_peers() {
  local bootstrap_peers="${BOOTSTRAP_PEERS:-}"
  
  # If BOOTSTRAP_PEERS is set in .env, use that
  if [[ -n "$bootstrap_peers" ]]; then
    echo "Using bootstrap peers from environment: $bootstrap_peers"
    echo "$bootstrap_peers"
    return 0
  fi
  
  # Try to get peers from bootstrap-peers.toml
  if [[ -f "$BOOTSTRAP_PEERS_FILE" ]]; then
    bootstrap_peers=$(parse_bootstrap_peers "$BOOTSTRAP_PEERS_FILE")
    if [[ -n "$bootstrap_peers" ]]; then
      echo "Using bootstrap peers from $BOOTSTRAP_PEERS_FILE"
      
      # Validate peers if requested
      if [[ "$VALIDATE_PEERS" = true ]]; then
        bootstrap_peers=$(validate_peers "$bootstrap_peers") || {
          echo "Peer validation failed, but continuing with the available list."
          # Use the original list if validation fails completely
          bootstrap_peers=$(parse_bootstrap_peers "$BOOTSTRAP_PEERS_FILE")
        }
      fi
      
      echo "$bootstrap_peers"
      return 0
    fi
  fi
  
  # Try to extract from config file as a last resort
  if [[ -f "$CONFIG_FILE" ]]; then
    bootstrap_peers=$(grep -oP 'persistent_peers\s*=\s*"\K[^"]+' "$CONFIG_FILE" || echo "")
    if [[ -n "$bootstrap_peers" ]]; then
      echo "Using bootstrap peers from $CONFIG_FILE"
      echo "$bootstrap_peers"
      return 0
    fi
  fi
  
  echo "⚠️ No bootstrap peers found in any configuration source."
  echo "The node may not connect to the testnet without peers."
  echo ""
  return 1
}

# Start the node
start_node() {
  local peers=""
  local peers_flag=""
  
  # Try to get bootstrap peers with retry logic
  for ((i=1; i<=RETRY_COUNT; i++)); do
    echo "Attempt $i/$RETRY_COUNT to get bootstrap peers..."
    if peers=$(get_bootstrap_peers); then
      break
    elif [[ $i -lt $RETRY_COUNT ]]; then
      echo "Retrying in 5 seconds..."
      sleep 5
    fi
  done
  
  if [[ -n "$peers" ]]; then
    peers_flag="--p2p.persistent_peers $peers"
  fi
  
  echo "Starting ICN node to join testnet..."
  echo "  - Name: $NODE_NAME"
  echo "  - Data directory: $DATA_DIR"
  echo "  - Log level: $LOG_LEVEL"
  
  # shellcheck disable=SC2086
  "$NODE_BINARY" start --home "$DATA_DIR" --federation --storage --log-level "$LOG_LEVEL" $peers_flag
}

# Main script execution
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$script_dir"

check_node_binary
create_data_dir
init_node
start_node 
--- FILE: ./mesh-status.sh ---
#!/bin/bash
set -euo pipefail

# ICN Network Mesh Status Monitor
# Visualize mesh health, DAG consistency, and federation status

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Default values
LOCAL_NODE_URL="http://localhost:26657"
DATA_DIR="${HOME}/.icn"
LOG_FILE="${DATA_DIR}/logs/mesh-status.log"
PEERS_FILE="${SCRIPT_DIR}/../config/bootstrap-peers.toml"
CHECK_INTERVAL=0  # 0 means run once, >0 means monitor every X seconds
OUTPUT_FORMAT="text"  # text, json, or csv
MIN_PEERS=3  # Minimum number of peers needed for a healthy federation
MONITOR_DAG=true
MONITOR_PROPOSALS=true
MONITOR_FEDERATION=true
VERBOSE=false

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Monitor the health of the ICN node mesh network.

Options:
  --node-url URL        Local node RPC URL (default: http://localhost:26657)
  --peers-file FILE     TOML file with peer information (default: config/bootstrap-peers.toml)
  --monitor SEC         Run continuously, checking every SEC seconds (default: 0 = run once)
  --min-peers N         Minimum number of peers for healthy status (default: 3)
  --format FORMAT       Output format: text, json, or csv (default: text)
  --no-dag              Skip DAG consistency checks
  --no-proposals        Skip proposal consistency checks
  --no-federation       Skip federation status checks
  --verbose             Show more detailed information
  --help                Display this help message and exit

Examples:
  # Check mesh status once
  $(basename "$0")
  
  # Monitor continuously every 60 seconds with JSON output
  $(basename "$0") --monitor 60 --format json
  
  # Check only federation status
  $(basename "$0") --no-dag --no-proposals
EOF
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --node-url)
        LOCAL_NODE_URL="$2"
        shift 2
        ;;
      --peers-file)
        PEERS_FILE="$2"
        shift 2
        ;;
      --monitor)
        CHECK_INTERVAL="$2"
        shift 2
        ;;
      --min-peers)
        MIN_PEERS="$2"
        shift 2
        ;;
      --format)
        OUTPUT_FORMAT="$2"
        shift 2
        ;;
      --no-dag)
        MONITOR_DAG=false
        shift
        ;;
      --no-proposals)
        MONITOR_PROPOSALS=false
        shift
        ;;
      --no-federation)
        MONITOR_FEDERATION=false
        shift
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done
}

validate_args() {
  # Create log directory
  mkdir -p "$(dirname "$LOG_FILE")"
  
  # Validate output format
  if [[ ! "$OUTPUT_FORMAT" =~ ^(text|json|csv)$ ]]; then
    log_error "Invalid output format: $OUTPUT_FORMAT. Must be one of: text, json, csv"
    exit 1
  fi
  
  # Check if local node is running
  if ! curl -s "${LOCAL_NODE_URL}/status" >/dev/null 2>&1; then
    log_error "Local node is not running at ${LOCAL_NODE_URL}"
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
      echo '{"status":"error","message":"Local node is not running","timestamp":"'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"}'
    elif [[ "$OUTPUT_FORMAT" == "csv" ]]; then
      echo "timestamp,status,message"
      echo "$(date -u +"%Y-%m-%dT%H:%M:%SZ"),error,Local node is not running"
    else
      echo "Error: Local node is not running at ${LOCAL_NODE_URL}"
    fi
    exit 1
  fi
  
  # Check if peers file exists when federation monitoring is enabled
  if [[ "$MONITOR_FEDERATION" == true && ! -f "$PEERS_FILE" ]]; then
    log_warn "Peers file not found: $PEERS_FILE"
    log_info "Will use only connected peers for federation status"
  fi
}

# Get local node information
get_local_node_info() {
  local status_json
  status_json=$(curl -s "${LOCAL_NODE_URL}/status")
  
  if ! command_exists jq; then
    log_error "jq is required for processing node information"
    return 1
  fi
  
  # Extract basic node information
  local node_id
  local node_network
  local node_moniker
  local block_height
  local catching_up
  
  node_id=$(echo "$status_json" | jq -r '.result.node_info.id')
  node_network=$(echo "$status_json" | jq -r '.result.node_info.network')
  node_moniker=$(echo "$status_json" | jq -r '.result.node_info.moniker')
  block_height=$(echo "$status_json" | jq -r '.result.sync_info.latest_block_height')
  catching_up=$(echo "$status_json" | jq -r '.result.sync_info.catching_up')
  
  # Output node info based on format
  if [[ "$OUTPUT_FORMAT" == "json" ]]; then
    jq -n \
      --arg id "$node_id" \
      --arg network "$node_network" \
      --arg moniker "$node_moniker" \
      --arg height "$block_height" \
      --argjson catching_up "$catching_up" \
      '{
        local_node: {
          id: $id,
          network: $network,
          moniker: $moniker,
          latest_block_height: $height,
          catching_up: $catching_up
        }
      }'
  elif [[ "$OUTPUT_FORMAT" == "csv" ]]; then
    echo "node_id,network,moniker,block_height,catching_up"
    echo "$node_id,$node_network,$node_moniker,$block_height,$catching_up"
  else
    echo "Local Node Information:"
    echo "ID:            $node_id"
    echo "Network:       $node_network"
    echo "Moniker:       $node_moniker"
    echo "Block Height:  $block_height"
    echo "Catching Up:   $catching_up"
  fi
}

# Get connected peers information
get_connected_peers() {
  local net_info
  net_info=$(curl -s "${LOCAL_NODE_URL}/net_info")
  
  if ! command_exists jq; then
    log_error "jq is required for processing peer information"
    return 1
  fi
  
  # Extract peer information
  local peer_count
  peer_count=$(echo "$net_info" | jq -r '.result.n_peers')
  
  local peers
  if [[ "$peer_count" -gt 0 ]]; then
    peers=$(echo "$net_info" | jq -c '.result.peers')
  else
    peers="[]"
  fi
  
  # Output peer info based on format
  if [[ "$OUTPUT_FORMAT" == "json" ]]; then
    jq -n \
      --arg count "$peer_count" \
      --argjson peers "$peers" \
      '{
        peers: {
          count: $count|tonumber,
          connected: $peers
        }
      }'
  elif [[ "$OUTPUT_FORMAT" == "csv" ]]; then
    echo "peer_count"
    echo "$peer_count"
    
    if [[ "$peer_count" -gt 0 ]]; then
      echo ""
      echo "peer_id,moniker,ip,port"
      echo "$net_info" | jq -r '.result.peers[] | [.node_info.id, .node_info.moniker, .remote_ip, (.node_info.listen_addr | split(":") | .[2])] | @csv'
    fi
  else
    echo "Connected Peers: $peer_count"
    
    if [[ "$peer_count" -gt 0 ]]; then
      echo "$net_info" | jq -r '.result.peers[] | "- \(.node_info.id): \(.node_info.moniker) (\(.remote_ip):\(.node_info.listen_addr | split(":") | .[2]))"'
    fi
    
    # Assess federation health
    if [[ "$peer_count" -ge "$MIN_PEERS" ]]; then
      echo "Federation Status: Healthy (≥ $MIN_PEERS peers)"
    else
      echo "Federation Status: Unhealthy (< $MIN_PEERS peers)"
    fi
  fi
}

# Get remote peer status by connecting to their endpoints
get_remote_peer_status() {
  local peers_json
  peers_json=$(curl -s "${LOCAL_NODE_URL}/net_info" | jq -c '.result.peers')
  
  if ! command_exists jq; then
    log_error "jq is required for processing peer status"
    return 1
  fi
  
  # Prepare array to hold remote peer data
  local remote_data=()
  local remote_data_json="[]"
  
  # Get our local node latest block height for comparison
  local local_height
  local_height=$(curl -s "${LOCAL_NODE_URL}/status" | jq -r '.result.sync_info.latest_block_height')
  
  # For each connected peer, try to get their status
  local peer_count
  peer_count=$(echo "$peers_json" | jq -r '. | length')
  
  for ((i=0; i<peer_count; i++)); do
    local peer_ip
    local peer_p2p_port
    local peer_rpc_port
    local peer_id
    local peer_moniker
    
    peer_ip=$(echo "$peers_json" | jq -r ".[$i].remote_ip")
    # Get P2P port from the listen_addr (assuming format is "tcp://0.0.0.0:PORT")
    peer_p2p_port=$(echo "$peers_json" | jq -r ".[$i].node_info.listen_addr" | cut -d':' -f3)
    # Assume RPC port is P2P port + 1 (common convention)
    peer_rpc_port=$((peer_p2p_port + 1))
    peer_id=$(echo "$peers_json" | jq -r ".[$i].node_info.id")
    peer_moniker=$(echo "$peers_json" | jq -r ".[$i].node_info.moniker")
    
    # Try to get remote node status
    local remote_status
    local remote_height
    local remote_catching_up
    local height_diff
    local status_ok
    
    if curl -s --connect-timeout 2 "http://${peer_ip}:${peer_rpc_port}/status" > /dev/null 2>&1; then
      remote_status=$(curl -s "http://${peer_ip}:${peer_rpc_port}/status")
      remote_height=$(echo "$remote_status" | jq -r '.result.sync_info.latest_block_height')
      remote_catching_up=$(echo "$remote_status" | jq -r '.result.sync_info.catching_up')
      
      # Calculate block height difference
      if [[ "$remote_height" =~ ^[0-9]+$ && "$local_height" =~ ^[0-9]+$ ]]; then
        height_diff=$((remote_height - local_height))
      else
        height_diff="unknown"
      fi
      
      status_ok=true
    else
      remote_height="unreachable"
      remote_catching_up="unknown"
      height_diff="unknown"
      status_ok=false
    fi
    
    # Add to remote_data array for later formatting
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
      local peer_json
      peer_json=$(jq -n \
        --arg id "$peer_id" \
        --arg moniker "$peer_moniker" \
        --arg ip "$peer_ip" \
        --arg port "$peer_rpc_port" \
        --arg height "$remote_height" \
        --arg height_diff "$height_diff" \
        --arg catching_up "$remote_catching_up" \
        --arg reachable "$status_ok" \
        '{
          id: $id,
          moniker: $moniker,
          ip: $ip,
          rpc_port: $port,
          latest_block_height: $height,
          height_diff: $height_diff,
          catching_up: $catching_up,
          reachable: $reachable
        }')
      
      remote_data_json=$(echo "$remote_data_json" | jq ". += [$peer_json]")
    elif [[ "$OUTPUT_FORMAT" == "csv" ]]; then
      remote_data+=("$peer_id,$peer_moniker,$peer_ip,$peer_rpc_port,$remote_height,$height_diff,$remote_catching_up,$status_ok")
    else
      if [[ "$status_ok" == true ]]; then
        remote_data+=("$peer_moniker ($peer_id): Block: $remote_height (diff: $height_diff), Catching up: $remote_catching_up")
      else
        remote_data+=("$peer_moniker ($peer_id): Unreachable at $peer_ip:$peer_rpc_port")
      fi
    fi
  done
  
  # Output remote peer status based on format
  if [[ "$OUTPUT_FORMAT" == "json" ]]; then
    echo "$remote_data_json" | jq '{remote_peers: .}'
  elif [[ "$OUTPUT_FORMAT" == "csv" ]]; then
    echo "peer_id,moniker,ip,rpc_port,block_height,height_diff,catching_up,reachable"
    printf "%s\n" "${remote_data[@]}"
  else
    echo "Remote Peer Status:"
    for data in "${remote_data[@]}"; do
      echo "- $data"
    done
  fi
}

# Get DAG consistency across nodes
check_dag_consistency() {
  if [[ "$MONITOR_DAG" == false ]]; then
    return 0
  fi
  
  if ! command_exists jq; then
    log_error "jq is required for checking DAG consistency"
    return 1
  fi
  
  # Get local DAG info
  local local_dag_info
  if [[ -x "${SCRIPT_DIR}/replay-dag.sh" ]]; then
    local_dag_info=$("${SCRIPT_DIR}/replay-dag.sh" --json 2>/dev/null || echo '{"vertices": 0, "proposals": 0, "votes": 0, "dag_hash": "unknown"}')
  else
    log_warn "replay-dag.sh script not found, skipping DAG consistency check"
    return 1
  fi
  
  local local_vertices
  local local_proposals
  local local_votes
  local local_dag_hash
  
  local_vertices=$(echo "$local_dag_info" | jq -r '.vertices // 0')
  local_proposals=$(echo "$local_dag_info" | jq -r '.proposals // 0')
  local_votes=$(echo "$local_dag_info" | jq -r '.votes // 0')
  local_dag_hash=$(echo "$local_dag_info" | jq -r '.dag_hash // "unknown"')
  
  # Get remote peer information
  local peers_json
  peers_json=$(curl -s "${LOCAL_NODE_URL}/net_info" | jq -c '.result.peers')
  
  local peer_count
  peer_count=$(echo "$peers_json" | jq -r '. | length')
  
  # Prepare arrays for storing remote DAG info
  local remote_dag_data=()
  local remote_dag_json="[]"
  local consistent_peers=0
  local inconsistent_peers=0
  local unreachable_peers=0
  
  # Check DAG state on each peer
  for ((i=0; i<peer_count; i++)); do
    local peer_ip
    local peer_p2p_port
    local peer_rpc_port
    local peer_id
    local peer_moniker
    
    peer_ip=$(echo "$peers_json" | jq -r ".[$i].remote_ip")
    peer_p2p_port=$(echo "$peers_json" | jq -r ".[$i].node_info.listen_addr" | cut -d':' -f3)
    peer_rpc_port=$((peer_p2p_port + 1))
    peer_id=$(echo "$peers_json" | jq -r ".[$i].node_info.id")
    peer_moniker=$(echo "$peers_json" | jq -r ".[$i].node_info.moniker")
    
    # Try to get remote DAG info
    local remote_dag_url="http://${peer_ip}:${peer_rpc_port}/abci_query?path=\"/dag/info\""
    local remote_dag_info
    local remote_vertices
    local remote_proposals
    local remote_votes
    local remote_dag_hash
    local is_consistent
    local status_ok
    
    if curl -s --connect-timeout 2 "$remote_dag_url" > /dev/null 2>&1; then
      remote_dag_info=$(curl -s "$remote_dag_url")
      
      # Try to extract DAG info from response
      if echo "$remote_dag_info" | jq -e '.result.response.value' > /dev/null 2>&1; then
        # Decode base64 value if present
        local dag_data
        dag_data=$(echo "$remote_dag_info" | jq -r '.result.response.value' | base64 -d 2>/dev/null || echo '{}')
        
        remote_vertices=$(echo "$dag_data" | jq -r '.vertices // 0')
        remote_proposals=$(echo "$dag_data" | jq -r '.proposals // 0')
        remote_votes=$(echo "$dag_data" | jq -r '.votes // 0')
        remote_dag_hash=$(echo "$dag_data" | jq -r '.dag_hash // "unknown"')
        
        # Check consistency based on DAG hash
        if [[ "$remote_dag_hash" == "$local_dag_hash" && "$local_dag_hash" != "unknown" ]]; then
          is_consistent=true
          consistent_peers=$((consistent_peers + 1))
        else
          is_consistent=false
          inconsistent_peers=$((inconsistent_peers + 1))
        fi
        
        status_ok=true
      else
        remote_vertices="unknown"
        remote_proposals="unknown"
        remote_votes="unknown"
        remote_dag_hash="unknown"
        is_consistent=false
        inconsistent_peers=$((inconsistent_peers + 1))
        status_ok=true
      fi
    else
      remote_vertices="unreachable"
      remote_proposals="unreachable"
      remote_votes="unreachable"
      remote_dag_hash="unreachable"
      is_consistent=false
      unreachable_peers=$((unreachable_peers + 1))
      status_ok=false
    fi
    
    # Add to remote_dag_data array for later formatting
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
      local dag_json
      dag_json=$(jq -n \
        --arg id "$peer_id" \
        --arg moniker "$peer_moniker" \
        --arg ip "$peer_ip" \
        --arg vertices "$remote_vertices" \
        --arg proposals "$remote_proposals" \
        --arg votes "$remote_votes" \
        --arg dag_hash "$remote_dag_hash" \
        --arg consistent "$is_consistent" \
        --arg reachable "$status_ok" \
        '{
          id: $id,
          moniker: $moniker,
          ip: $ip,
          vertices: $vertices,
          proposals: $proposals,
          votes: $votes,
          dag_hash: $dag_hash,
          consistent: $consistent,
          reachable: $reachable
        }')
      
      remote_dag_json=$(echo "$remote_dag_json" | jq ". += [$dag_json]")
    elif [[ "$OUTPUT_FORMAT" == "csv" ]]; then
      remote_dag_data+=("$peer_id,$peer_moniker,$peer_ip,$remote_vertices,$remote_proposals,$remote_votes,$remote_dag_hash,$is_consistent,$status_ok")
    else
      if [[ "$status_ok" == true ]]; then
        local consistency_status
        if [[ "$is_consistent" == true ]]; then
          consistency_status="Consistent"
        else
          consistency_status="Inconsistent"
        fi
        remote_dag_data+=("$peer_moniker ($peer_id): Vertices: $remote_vertices, Proposals: $remote_proposals, Votes: $remote_votes, Status: $consistency_status")
      else
        remote_dag_data+=("$peer_moniker ($peer_id): DAG info unreachable")
      fi
    fi
  done
  
  # Calculate overall DAG consistency
  local total_reachable=$((consistent_peers + inconsistent_peers))
  local consistency_percentage
  
  if [[ $total_reachable -gt 0 ]]; then
    consistency_percentage=$((consistent_peers * 100 / total_reachable))
  else
    consistency_percentage=0
  fi
  
  # Output DAG consistency info based on format
  if [[ "$OUTPUT_FORMAT" == "json" ]]; then
    jq -n \
      --arg vertices "$local_vertices" \
      --arg proposals "$local_proposals" \
      --arg votes "$local_votes" \
      --arg dag_hash "$local_dag_hash" \
      --arg consistent_peers "$consistent_peers" \
      --arg inconsistent_peers "$inconsistent_peers" \
      --arg unreachable_peers "$unreachable_peers" \
      --arg consistency_percentage "$consistency_percentage" \
      --argjson remote_data "$remote_dag_json" \
      '{
        dag_consistency: {
          local_node: {
            vertices: $vertices,
            proposals: $proposals,
            votes: $votes,
            dag_hash: $dag_hash
          },
          stats: {
            consistent_peers: $consistent_peers|tonumber,
            inconsistent_peers: $inconsistent_peers|tonumber,
            unreachable_peers: $unreachable_peers|tonumber,
            consistency_percentage: $consistency_percentage|tonumber
          },
          remote_nodes: $remote_data
        }
      }'
  elif [[ "$OUTPUT_FORMAT" == "csv" ]]; then
    echo "local_vertices,local_proposals,local_votes,local_dag_hash,consistent_peers,inconsistent_peers,unreachable_peers,consistency_percentage"
    echo "$local_vertices,$local_proposals,$local_votes,$local_dag_hash,$consistent_peers,$inconsistent_peers,$unreachable_peers,$consistency_percentage%"
    
    echo ""
    echo "peer_id,moniker,ip,vertices,proposals,votes,dag_hash,consistent,reachable"
    printf "%s\n" "${remote_dag_data[@]}"
  else
    echo "DAG Consistency:"
    echo "Local DAG: Vertices: $local_vertices, Proposals: $local_proposals, Votes: $local_votes"
    echo "DAG Hash: $local_dag_hash"
    echo "Consistency: $consistency_percentage% ($consistent_peers consistent, $inconsistent_peers inconsistent, $unreachable_peers unreachable)"
    
    echo "Remote DAG Status:"
    for data in "${remote_dag_data[@]}"; do
      echo "- $data"
    done
  fi
}

# Check proposal consistency across nodes
check_proposal_consistency() {
  if [[ "$MONITOR_PROPOSALS" == false ]]; then
    return 0
  fi
  
  if ! command_exists jq; then
    log_error "jq is required for checking proposal consistency"
    return 1
  fi
  
  # Get local proposals
  local local_proposals
  if [[ -x "${SCRIPT_DIR}/replay-dag.sh" ]]; then
    local_proposals=$("${SCRIPT_DIR}/replay-dag.sh" --proposals --json 2>/dev/null || echo '[]')
  else
    log_warn "replay-dag.sh script not found, skipping proposal consistency check"
    return 1
  fi
  
  # Count local proposals
  local local_proposal_count
  local_proposal_count=$(echo "$local_proposals" | jq -r '. | length')
  
  # Extract local proposal IDs for comparison
  local local_proposal_ids
  local_proposal_ids=$(echo "$local_proposals" | jq -r '.[].id')
  
  # Get remote peer information
  local peers_json
  peers_json=$(curl -s "${LOCAL_NODE_URL}/net_info" | jq -c '.result.peers')
  
  local peer_count
  peer_count=$(echo "$peers_json" | jq -r '. | length')
  
  # Prepare arrays for storing remote proposal info
  local remote_proposal_data=()
  local remote_proposal_json="[]"
  local fully_consistent_peers=0
  local partially_consistent_peers=0
  local inconsistent_peers=0
  local unreachable_peers=0
  
  # Check proposals on each peer
  for ((i=0; i<peer_count; i++)); do
    local peer_ip
    local peer_p2p_port
    local peer_rpc_port
    local peer_id
    local peer_moniker
    
    peer_ip=$(echo "$peers_json" | jq -r ".[$i].remote_ip")
    peer_p2p_port=$(echo "$peers_json" | jq -r ".[$i].node_info.listen_addr" | cut -d':' -f3)
    peer_rpc_port=$((peer_p2p_port + 1))
    peer_id=$(echo "$peers_json" | jq -r ".[$i].node_info.id")
    peer_moniker=$(echo "$peers_json" | jq -r ".[$i].node_info.moniker")
    
    # Try to get remote proposals
    local remote_proposals_url="http://${peer_ip}:${peer_rpc_port}/abci_query?path=\"/proposals/list\""
    local remote_proposals
    local remote_proposal_count
    local remote_proposal_ids
    local matching_proposals
    local consistency_status
    local status_ok
    
    if curl -s --connect-timeout 2 "$remote_proposals_url" > /dev/null 2>&1; then
      remote_proposals=$(curl -s "$remote_proposals_url")
      
      # Try to extract proposal info from response
      if echo "$remote_proposals" | jq -e '.result.response.value' > /dev/null 2>&1; then
        # Decode base64 value if present
        local proposals_data
        proposals_data=$(echo "$remote_proposals" | jq -r '.result.response.value' | base64 -d 2>/dev/null || echo '[]')
        
        remote_proposal_count=$(echo "$proposals_data" | jq -r '. | length')
        remote_proposal_ids=$(echo "$proposals_data" | jq -r '.[].id')
        
        # Count matching proposals
        local matching_count=0
        local total_proposals
        
        for id in $remote_proposal_ids; do
          if echo "$local_proposal_ids" | grep -q "$id"; then
            matching_count=$((matching_count + 1))
          fi
        done
        
        # Get total number of unique proposals
        total_proposals=$(echo -e "$remote_proposal_ids\n$local_proposal_ids" | sort -u | wc -l | tr -d ' ')
        
        matching_proposals=$matching_count
        
        # Determine consistency status
        if [[ $matching_count -eq $total_proposals ]]; then
          consistency_status="Fully Consistent"
          fully_consistent_peers=$((fully_consistent_peers + 1))
        elif [[ $matching_count -gt 0 ]]; then
          consistency_status="Partially Consistent"
          partially_consistent_peers=$((partially_consistent_peers + 1))
        else
          consistency_status="Inconsistent"
          inconsistent_peers=$((inconsistent_peers + 1))
        fi
        
        status_ok=true
      else
        remote_proposal_count="unknown"
        remote_proposal_ids=""
        matching_proposals=0
        consistency_status="Unknown"
        inconsistent_peers=$((inconsistent_peers + 1))
        status_ok=true
      fi
    else
      remote_proposal_count="unreachable"
      remote_proposal_ids=""
      matching_proposals=0
      consistency_status="Unreachable"
      unreachable_peers=$((unreachable_peers + 1))
      status_ok=false
    fi
    
    # Add to remote_proposal_data array for later formatting
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
      local proposal_json
      proposal_json=$(jq -n \
        --arg id "$peer_id" \
        --arg moniker "$peer_moniker" \
        --arg ip "$peer_ip" \
        --arg count "$remote_proposal_count" \
        --arg matching "$matching_proposals" \
        --arg status "$consistency_status" \
        --arg reachable "$status_ok" \
        '{
          id: $id,
          moniker: $moniker,
          ip: $ip,
          proposal_count: $count,
          matching_proposals: $matching,
          consistency_status: $status,
          reachable: $reachable
        }')
      
      remote_proposal_json=$(echo "$remote_proposal_json" | jq ". += [$proposal_json]")
    elif [[ "$OUTPUT_FORMAT" == "csv" ]]; then
      remote_proposal_data+=("$peer_id,$peer_moniker,$peer_ip,$remote_proposal_count,$matching_proposals,$consistency_status,$status_ok")
    else
      if [[ "$status_ok" == true ]]; then
        remote_proposal_data+=("$peer_moniker ($peer_id): Proposals: $remote_proposal_count, Matching: $matching_proposals, Status: $consistency_status")
      else
        remote_proposal_data+=("$peer_moniker ($peer_id): Proposal info unreachable")
      fi
    fi
  done
  
  # Calculate overall proposal consistency
  local total_reachable=$((fully_consistent_peers + partially_consistent_peers + inconsistent_peers))
  local consistency_percentage
  
  if [[ $total_reachable -gt 0 ]]; then
    # Full consistency is weighted more than partial
    consistency_percentage=$(( (fully_consistent_peers * 100 + partially_consistent_peers * 50) / (total_reachable * 100) * 100 ))
  else
    consistency_percentage=0
  fi
  
  # Output proposal consistency info based on format
  if [[ "$OUTPUT_FORMAT" == "json" ]]; then
    jq -n \
      --arg count "$local_proposal_count" \
      --arg fully_consistent "$fully_consistent_peers" \
      --arg partially_consistent "$partially_consistent_peers" \
      --arg inconsistent "$inconsistent_peers" \
      --arg unreachable "$unreachable_peers" \
      --arg consistency_percentage "$consistency_percentage" \
      --argjson remote_data "$remote_proposal_json" \
      '{
        proposal_consistency: {
          local_node: {
            proposal_count: $count|tonumber
          },
          stats: {
            fully_consistent_peers: $fully_consistent|tonumber,
            partially_consistent_peers: $partially_consistent|tonumber,
            inconsistent_peers: $inconsistent|tonumber,
            unreachable_peers: $unreachable|tonumber,
            consistency_percentage: $consistency_percentage|tonumber
          },
          remote_nodes: $remote_data
        }
      }'
  elif [[ "$OUTPUT_FORMAT" == "csv" ]]; then
    echo "local_proposal_count,fully_consistent_peers,partially_consistent_peers,inconsistent_peers,unreachable_peers,consistency_percentage"
    echo "$local_proposal_count,$fully_consistent_peers,$partially_consistent_peers,$inconsistent_peers,$unreachable_peers,$consistency_percentage%"
    
    echo ""
    echo "peer_id,moniker,ip,proposal_count,matching_proposals,consistency_status,reachable"
    printf "%s\n" "${remote_proposal_data[@]}"
  else
    echo "Proposal Consistency:"
    echo "Local Proposals: $local_proposal_count"
    echo "Consistency: $consistency_percentage% ($fully_consistent_peers fully consistent, $partially_consistent_peers partially consistent, $inconsistent_peers inconsistent, $unreachable_peers unreachable)"
    
    echo "Remote Proposal Status:"
    for data in "${remote_proposal_data[@]}"; do
      echo "- $data"
    done
  fi
}

# Generate the full mesh status report
generate_mesh_status_report() {
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  if [[ "$OUTPUT_FORMAT" == "json" ]]; then
    # For JSON output, we combine all the individual reports
    local node_info
    local peers_info
    local dag_consistency
    local proposal_consistency
    
    node_info=$(get_local_node_info)
    peers_info=$(get_connected_peers)
    
    if [[ "$MONITOR_DAG" == true ]]; then
      dag_consistency=$(check_dag_consistency)
    else
      dag_consistency="{}"
    fi
    
    if [[ "$MONITOR_PROPOSALS" == true ]]; then
      proposal_consistency=$(check_proposal_consistency)
    else
      proposal_consistency="{}"
    fi
    
    # Combine all data
    jq -n \
      --arg timestamp "$timestamp" \
      --argjson node_info "$node_info" \
      --argjson peers_info "$peers_info" \
      --argjson dag_consistency "$dag_consistency" \
      --argjson proposal_consistency "$proposal_consistency" \
      '{
        timestamp: $timestamp,
        node_info: $node_info.local_node,
        peers_info: $peers_info.peers,
        dag_consistency: $dag_consistency.dag_consistency,
        proposal_consistency: $proposal_consistency.proposal_consistency
      }'
  elif [[ "$OUTPUT_FORMAT" == "csv" ]]; then
    # For CSV output, we keep each section separate
    echo "ICN Mesh Status Report - $timestamp"
    echo ""
    
    get_local_node_info
    echo ""
    
    get_connected_peers
    echo ""
    
    if [[ "$MONITOR_DAG" == true ]]; then
      check_dag_consistency
      echo ""
    fi
    
    if [[ "$MONITOR_PROPOSALS" == true ]]; then
      check_proposal_consistency
    fi
  else
    # For text output, we format a readable report
    echo "==================================================="
    echo "ICN MESH STATUS REPORT - $timestamp"
    echo "==================================================="
    echo ""
    
    get_local_node_info
    echo ""
    
    get_connected_peers
    echo ""
    
    if [[ "$MONITOR_DAG" == true ]]; then
      check_dag_consistency
      echo ""
    fi
    
    if [[ "$MONITOR_PROPOSALS" == true ]]; then
      check_proposal_consistency
    fi
    
    echo "==================================================="
  fi
}

# Monitor the mesh continuously
monitor_mesh() {
  log_info "Starting mesh monitoring with interval of $CHECK_INTERVAL seconds"
  
  while true; do
    generate_mesh_status_report
    
    if [[ "$CHECK_INTERVAL" -le 0 ]]; then
      # Run once and exit
      break
    else
      # Sleep until next check
      sleep "$CHECK_INTERVAL"
    fi
  done
}

# Main function
main() {
  parse_args "$@"
  validate_args
  
  monitor_mesh
}

main "$@" 
--- FILE: ./mobile-agent.sh ---
#!/bin/bash
set -euo pipefail

# ICN Mobile Agent Stub
# Provides JSON state for mobile agent integration

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Default values
NODE_URL="http://localhost:26657"
DATA_DIR="${HOME}/.icn"
LOG_FILE="${DATA_DIR}/logs/mobile-agent.log"
IDENTITY_PATH="${HOME}/.wallet/identities"
SOCKET_PORT=8099
API_PORT=9001
COOP_NAME="default"
WATCH_INTERVAL=5  # Seconds between state updates
ENABLE_SOCKET=true
ENABLE_API=true
ENABLE_IDENTITY=true
ENABLE_PROPOSALS=true
RUN_AS_DAEMON=false
VERBOSE=false

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS]

ICN Mobile Agent Stub - Provides state data for mobile integrations.

Options:
  --node-url URL        ICN node RPC URL (default: http://localhost:26657)
  --socket-port PORT    WebSocket port for state updates (default: 8099)
  --api-port PORT       REST API port (default: 9001)
  --coop NAME           Default cooperative name (default: default)
  --watch-interval SEC  Seconds between state updates (default: 5)
  --no-socket           Disable WebSocket server
  --no-api              Disable REST API server
  --no-identity         Disable identity monitoring
  --no-proposals        Disable proposal monitoring
  --daemon              Run as a daemon in the background
  --verbose             Enable verbose logging
  --help                Display this help message and exit

Examples:
  # Start with default settings
  $(basename "$0")
  
  # Run as daemon with custom watch interval
  $(basename "$0") --daemon --watch-interval 10
  
  # Only monitor proposals with REST API (no WebSocket)
  $(basename "$0") --no-socket --no-identity
EOF
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --node-url)
        NODE_URL="$2"
        shift 2
        ;;
      --socket-port)
        SOCKET_PORT="$2"
        shift 2
        ;;
      --api-port)
        API_PORT="$2"
        shift 2
        ;;
      --coop)
        COOP_NAME="$2"
        shift 2
        ;;
      --watch-interval)
        WATCH_INTERVAL="$2"
        shift 2
        ;;
      --no-socket)
        ENABLE_SOCKET=false
        shift
        ;;
      --no-api)
        ENABLE_API=false
        shift
        ;;
      --no-identity)
        ENABLE_IDENTITY=false
        shift
        ;;
      --no-proposals)
        ENABLE_PROPOSALS=false
        shift
        ;;
      --daemon)
        RUN_AS_DAEMON=true
        shift
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done
}

validate_args() {
  # Create log directory
  mkdir -p "$(dirname "$LOG_FILE")"
  
  # Check if either socket or API is enabled
  if [[ "$ENABLE_SOCKET" == false && "$ENABLE_API" == false ]]; then
    log_error "At least one of WebSocket or REST API must be enabled"
    exit 1
  fi
  
  # Check if essential tools are available
  for cmd in nc curl jq; do
    if ! command_exists "$cmd"; then
      log_warn "Command '$cmd' not found. Some features may not work correctly."
    fi
  done
  
  # If socket is enabled, check if the port is available
  if [[ "$ENABLE_SOCKET" == true ]]; then
    if is_port_in_use "$SOCKET_PORT"; then
      log_error "Socket port $SOCKET_PORT is already in use"
      exit 1
    fi
  fi
  
  # If API is enabled, check if the port is available
  if [[ "$ENABLE_API" == true ]]; then
    if is_port_in_use "$API_PORT"; then
      log_error "API port $API_PORT is already in use"
      exit 1
    fi
  fi
}

# Get node status
get_node_status() {
  if ! curl -s "${NODE_URL}/status" >/dev/null 2>&1; then
    echo '{"status":"offline"}'
    return 1
  fi
  
  local node_info
  node_info=$(curl -s "${NODE_URL}/status")
  
  if command_exists jq; then
    # Extract relevant node information
    local status
    status=$(jq -n \
      --argjson full_info "$node_info" \
      '{
        status: "online",
        node_id: ($full_info.result.node_info.id // "unknown"),
        network: ($full_info.result.node_info.network // "unknown"),
        latest_block_height: ($full_info.result.sync_info.latest_block_height // "0" | tonumber),
        latest_block_time: ($full_info.result.sync_info.latest_block_time // null),
        catching_up: ($full_info.result.sync_info.catching_up // false),
        timestamp: "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"
      }')
    echo "$status"
  else
    # Fallback if jq is not available
    echo '{"status":"online", "raw_data":true}'
  fi
}

# Get identity information
get_identity_info() {
  if [[ "$ENABLE_IDENTITY" == false ]]; then
    echo '{"identities":[]}'
    return 0
  fi
  
  # Check if identity directory exists
  if [[ ! -d "$IDENTITY_PATH" ]]; then
    echo '{"identities":[]}'
    return 0
  fi
  
  if command_exists jq; then
    local identities_json="[]"
    local coops=()
    
    # Find all cooperatives
    for coop_dir in "$IDENTITY_PATH"/*; do
      if [[ -d "$coop_dir" ]]; then
        coops+=("$(basename "$coop_dir")")
      fi
    done
    
    # Process each cooperative
    for coop in "${coops[@]}"; do
      for identity_file in "$IDENTITY_PATH/$coop"/*.json; do
        if [[ -f "$identity_file" ]]; then
          local identity_name
          identity_name=$(basename "$identity_file" .json)
          
          # Read identity JSON
          local identity_json
          identity_json=$(cat "$identity_file")
          
          # Add cooperative and name to the identity JSON
          local enhanced_json
          enhanced_json=$(echo "$identity_json" | jq \
            --arg coop "$coop" \
            --arg name "$identity_name" \
            '. + {cooperative: $coop, name: $name}')
          
          # Append to identities array
          identities_json=$(echo "$identities_json" | jq \
            --argjson identity "$enhanced_json" \
            '. += [$identity]')
        fi
      done
    done
    
    echo "{\"identities\":$identities_json}"
  else
    # Fallback if jq is not available
    echo '{"identities":[], "error":"jq not available"}'
  fi
}

# Get active proposals
get_proposals() {
  if [[ "$ENABLE_PROPOSALS" == false ]]; then
    echo '{"proposals":[]}'
    return 0
  fi
  
  # Check if node is running
  if ! curl -s "${NODE_URL}/status" >/dev/null 2>&1; then
    echo '{"proposals":[], "error":"node offline"}'
    return 1
  fi
  
  # Check if replay-dag.sh is available
  if [[ ! -x "${SCRIPT_DIR}/replay-dag.sh" ]]; then
    echo '{"proposals":[], "error":"replay-dag.sh not available"}'
    return 1
  fi
  
  local proposals_json
  proposals_json=$("${SCRIPT_DIR}/replay-dag.sh" --proposals --json 2>/dev/null || echo '[]')
  
  echo "{\"proposals\":$proposals_json}"
}

# Generate the complete state object
generate_state() {
  local node_status
  local identities
  local proposals
  
  # Get individual components
  node_status=$(get_node_status)
  identities=$(get_identity_info)
  proposals=$(get_proposals)
  
  if command_exists jq; then
    # Combine all data into a single JSON object
    local state
    state=$(jq -n \
      --argjson node "$node_status" \
      --argjson identities "$identities" \
      --argjson proposals "$proposals" \
      '{
        node: $node,
        identities: $identities.identities,
        proposals: $proposals.proposals,
        agent: {
          version: "0.1.0",
          timestamp: "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"
        }
      }')
    echo "$state"
  else
    # Fallback if jq is not available
    echo "{\"node\":$node_status, \"identities\":${identities}, \"proposals\":${proposals}}"
  fi
}

# --------------------------
# WebSocket Server Functions
# --------------------------

start_socket_server() {
  log_info "Starting WebSocket server on port $SOCKET_PORT"
  
  # Create a FIFO for communication
  local fifo_path="/tmp/icn-mobile-agent-$$.fifo"
  mkfifo "$fifo_path"
  
  # Clean up FIFO on exit
  trap 'rm -f "$fifo_path"' EXIT
  
  # Start socket server in background
  (
    # Simple WebSocket server using netcat
    while true; do
      nc -l "$SOCKET_PORT" < "$fifo_path" | while read -r line; do
        # Simple WebSocket handshake
        if [[ "$line" == *"Upgrade: websocket"* ]]; then
          local key
          key=$(echo "$line" | grep -o "Sec-WebSocket-Key: [^$]+" | cut -d' ' -f2)
          if [[ -n "$key" ]]; then
            log_debug "WebSocket handshake detected, key: $key"
            
            # Send WebSocket handshake response
            local response="HTTP/1.1 101 Switching Protocols\r\n"
            response+="Upgrade: websocket\r\n"
            response+="Connection: Upgrade\r\n"
            response+="Sec-WebSocket-Accept: $(echo -n "$key" | openssl dgst -sha1 -binary | base64)\r\n"
            response+="\r\n"
            
            echo -e "$response" > "$fifo_path"
            
            # Start sending state updates
            while true; do
              local state
              state=$(generate_state)
              echo -e "$state" > "$fifo_path"
              sleep "$WATCH_INTERVAL"
            done
          fi
        fi
      done
    done
  ) &
  
  log_info "WebSocket server started on port $SOCKET_PORT"
}

# ------------------------
# REST API Server Functions
# ------------------------

start_api_server() {
  log_info "Starting REST API server on port $API_PORT"
  
  # Check if socat is available (required for REST API)
  if ! command_exists socat; then
    log_error "socat is required for the REST API server but not found"
    return 1
  fi
  
  # Start API server in background
  (
    # Simple HTTP server using socat
    socat TCP-LISTEN:"$API_PORT",fork,reuseaddr EXEC:"${SCRIPT_DIR}/mobile-agent-api-handler.sh"
  ) &
  
  log_info "REST API server started on port $API_PORT"
  
  # Create API handler script
  create_api_handler_script
}

create_api_handler_script() {
  local handler_script="${SCRIPT_DIR}/mobile-agent-api-handler.sh"
  
  cat > "$handler_script" <<'EOF'
#!/bin/bash
set -euo pipefail

# ICN Mobile Agent API Handler
# This script handles HTTP requests for the mobile agent API

# Read the HTTP request
read -r request_line
read -r request_method request_path request_proto <<< "$request_line"

# Read all headers
declare -A headers
while IFS=": " read -r key value; do
  # Break on empty line (end of headers)
  [[ -z "$key" ]] && break
  # Remove carriage return
  value="${value//$'\r'/}"
  headers["$key"]="$value"
done

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"

# Call the appropriate handler based on the path
case "$request_path" in
  "/state" | "/status")
    # Get the full state
    response=$("$SCRIPT_DIR/mobile-agent.sh" --get-state 2>/dev/null || echo '{"error":"Failed to get state"}')
    ;;
  "/node")
    # Get just node status
    response=$("$SCRIPT_DIR/mobile-agent.sh" --get-node 2>/dev/null || echo '{"error":"Failed to get node status"}')
    ;;
  "/identities")
    # Get identities
    response=$("$SCRIPT_DIR/mobile-agent.sh" --get-identities 2>/dev/null || echo '{"error":"Failed to get identities"}')
    ;;
  "/proposals")
    # Get proposals
    response=$("$SCRIPT_DIR/mobile-agent.sh" --get-proposals 2>/dev/null || echo '{"error":"Failed to get proposals"}')
    ;;
  "/health")
    # Simple health check
    response='{"status":"ok"}'
    ;;
  *)
    # Default to 404
    echo -e "HTTP/1.1 404 Not Found\r\nContent-Type: application/json\r\nContent-Length: 27\r\n\r\n{\"error\":\"Endpoint not found\"}"
    exit 0
    ;;
esac

# Calculate content length
content_length=${#response}

# Send HTTP response
echo -e "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: $content_length\r\n\r\n$response"
EOF

  chmod +x "$handler_script"
}

# Run as daemon
run_as_daemon() {
  log_info "Starting mobile agent in daemon mode"
  
  # Create a wrapper script
  local wrapper_script="/tmp/icn-mobile-agent-$$.sh"
  cat > "$wrapper_script" <<EOF
#!/bin/bash
set -euo pipefail
exec "$0" --node-url "$NODE_URL" --socket-port "$SOCKET_PORT" --api-port "$API_PORT" --coop "$COOP_NAME" --watch-interval "$WATCH_INTERVAL" $(if [[ "$ENABLE_SOCKET" == false ]]; then echo "--no-socket"; fi) $(if [[ "$ENABLE_API" == false ]]; then echo "--no-api"; fi) $(if [[ "$ENABLE_IDENTITY" == false ]]; then echo "--no-identity"; fi) $(if [[ "$ENABLE_PROPOSALS" == false ]]; then echo "--no-proposals"; fi) $(if [[ "$VERBOSE" == true ]]; then echo "--verbose"; fi)
EOF
  chmod +x "$wrapper_script"
  
  # Start in background
  nohup "$wrapper_script" > "$LOG_FILE" 2>&1 &
  echo $! > "${DATA_DIR}/mobile-agent.pid"
  log_info "Mobile agent started in daemon mode with PID $(cat "${DATA_DIR}/mobile-agent.pid")"
}

# Direct state query mode - used for API handlers
handle_direct_query() {
  case "$1" in
    --get-state)
      generate_state
      ;;
    --get-node)
      get_node_status
      ;;
    --get-identities)
      get_identity_info
      ;;
    --get-proposals)
      get_proposals
      ;;
    *)
      log_error "Unknown query command: $1"
      exit 1
      ;;
  esac
  exit 0
}

# Main function for running the agent
run_agent() {
  log_info "Starting ICN mobile agent"
  
  # Start socket server if enabled
  if [[ "$ENABLE_SOCKET" == true ]]; then
    start_socket_server
  fi
  
  # Start API server if enabled
  if [[ "$ENABLE_API" == true ]]; then
    start_api_server
  fi
  
  log_info "ICN mobile agent started"
  
  # Print server information
  if [[ "$ENABLE_SOCKET" == true ]]; then
    log_info "WebSocket server running on ws://localhost:$SOCKET_PORT"
  fi
  if [[ "$ENABLE_API" == true ]]; then
    log_info "REST API server running on http://localhost:$API_PORT"
    log_info "API endpoints: /state, /node, /identities, /proposals, /health"
  fi
  
  # Main loop - generate and display state periodically
  if [[ "$VERBOSE" == true ]]; then
    while true; do
      log_info "Generating state update..."
      local state
      state=$(generate_state)
      echo "$state" | jq '.'
      sleep "$WATCH_INTERVAL"
    done
  else
    # Just keep the script running
    while true; do
      sleep 60
    done
  fi
}

main() {
  # First, check for direct query mode
  if [[ $# -eq 1 && "$1" == --get-* ]]; then
    handle_direct_query "$1"
  fi
  
  parse_args "$@"
  validate_args
  
  # Run as daemon or foreground
  if [[ "$RUN_AS_DAEMON" == true ]]; then
    run_as_daemon
  else
    run_agent
  fi
}

main "$@" 
--- FILE: ./node-state.sh ---
#!/bin/bash
set -euo pipefail

# ICN Node State Manager
# This script manages a persistent state file for the ICN node

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Default values
DATA_DIR="${HOME}/.icn"
STATE_FILE="${DATA_DIR}/state/node_state.json"
BACKUP_DIR="${DATA_DIR}/state/backups"
VERBOSE=false
ROTATE_BACKUPS=10  # Number of backups to keep

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [COMMAND] [OPTIONS]

Manage ICN node state.

Commands:
  get KEY              Get value for a specific key
  set KEY VALUE        Set value for a specific key
  list                 List all state entries
  backup               Create a backup of the current state
  restore BACKUP       Restore state from a backup file
  clean                Remove old backups keeping only ${ROTATE_BACKUPS} most recent

Options:
  --data-dir DIR       Data directory (default: ~/.icn)
  --verbose            Enable verbose logging
  --help               Display this help message and exit

Examples:
  # Get a specific state value
  $(basename "$0") get lastProposalId
  
  # Set a state value
  $(basename "$0") set lastExecutedBlock 1000
  
  # List all state entries
  $(basename "$0") list
  
  # Backup the current state
  $(basename "$0") backup
EOF
}

parse_args() {
  COMMAND=""
  KEY=""
  VALUE=""
  BACKUP_FILE=""

  # Parse command if present
  if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
    COMMAND="$1"
    shift
  fi

  # Parse command arguments
  case "$COMMAND" in
    get)
      if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
        KEY="$1"
        shift
      else
        log_error "Missing key for 'get' command"
        print_usage
        exit 1
      fi
      ;;
    set)
      if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
        KEY="$1"
        shift
      else
        log_error "Missing key for 'set' command"
        print_usage
        exit 1
      fi
      
      if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
        VALUE="$1"
        shift
      else
        log_error "Missing value for 'set' command"
        print_usage
        exit 1
      fi
      ;;
    restore)
      if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
        BACKUP_FILE="$1"
        shift
      else
        log_error "Missing backup file for 'restore' command"
        print_usage
        exit 1
      fi
      ;;
    list|backup|clean)
      # These commands don't require additional arguments
      ;;
    "")
      log_error "Command required"
      print_usage
      exit 1
      ;;
    *)
      log_error "Unknown command: $COMMAND"
      print_usage
      exit 1
      ;;
  esac
  
  # Parse options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --data-dir)
        DATA_DIR="$2"
        STATE_FILE="${DATA_DIR}/state/node_state.json"
        BACKUP_DIR="${DATA_DIR}/state/backups"
        shift 2
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      *)
        log_error "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done
}

initialize_state() {
  # Create state directories if they don't exist
  mkdir -p "$(dirname "$STATE_FILE")"
  mkdir -p "$BACKUP_DIR"
  
  # Create initial state file if it doesn't exist
  if [[ ! -f "$STATE_FILE" ]]; then
    log_info "Initializing node state file"
    
    # Initialize with default values
    cat > "$STATE_FILE" <<EOF
{
  "nodeId": "$(uuidgen || echo "unknown-$(date +%s)")",
  "initialized": "$(date --iso-8601=seconds)",
  "lastUpdated": "$(date --iso-8601=seconds)",
  "lastExecutedBlock": 0,
  "lastProposalId": 0,
  "executedProposals": [],
  "activeConnection": "",
  "peers": [],
  "systemVersion": "$(git -C "$SCRIPT_DIR/.." describe --tags --always 2>/dev/null || echo "unknown")"
}
EOF
  fi
}

get_state_value() {
  local key="$1"
  
  if [[ ! -f "$STATE_FILE" ]]; then
    log_error "State file not found: $STATE_FILE"
    return 1
  fi
  
  # Try to get the value
  local value
  value=$(jq -r ".$key // \"\"" "$STATE_FILE")
  
  if [[ -z "$value" || "$value" == "null" ]]; then
    if [[ "$VERBOSE" == true ]]; then
      log_warn "Key not found in state: $key"
    fi
    echo ""
    return 1
  fi
  
  echo "$value"
  return 0
}

set_state_value() {
  local key="$1"
  local value="$2"
  
  initialize_state
  
  # Update the value
  log_info "Setting state: $key = $value"
  
  # Try to detect if value is a JSON object/array or a simple value
  if [[ "$value" =~ ^\{.*\}$ || "$value" =~ ^\[.*\]$ ]]; then
    # Value appears to be JSON, don't wrap in quotes
    jq --arg key "$key" --argjson value "$value" \
      '. + {($key): $value, "lastUpdated": now | todate}' "$STATE_FILE" > "${STATE_FILE}.tmp"
  else
    # Value is a simple value, treat as string
    jq --arg key "$key" --arg value "$value" \
      '. + {($key): $value, "lastUpdated": now | todate}' "$STATE_FILE" > "${STATE_FILE}.tmp"
  fi
  
  mv "${STATE_FILE}.tmp" "$STATE_FILE"
}

list_state() {
  if [[ ! -f "$STATE_FILE" ]]; then
    log_error "State file not found: $STATE_FILE"
    return 1
  fi
  
  log_info "Node state:"
  
  # Pretty print state
  jq '.' "$STATE_FILE"
}

backup_state() {
  if [[ ! -f "$STATE_FILE" ]]; then
    log_error "State file not found: $STATE_FILE"
    return 1
  }
  
  local timestamp
  timestamp=$(date +%Y%m%d_%H%M%S)
  local backup_file="${BACKUP_DIR}/node_state_${timestamp}.json"
  
  cp "$STATE_FILE" "$backup_file"
  log_success "State backup created: $backup_file"
  
  # Clean old backups if needed
  clean_old_backups
}

restore_state() {
  local backup_file="$1"
  
  if [[ ! -f "$backup_file" ]]; then
    log_error "Backup file not found: $backup_file"
    return 1
  }
  
  # Backup current state before restore
  backup_state
  
  # Restore from backup
  mkdir -p "$(dirname "$STATE_FILE")"
  cp "$backup_file" "$STATE_FILE"
  log_success "State restored from: $backup_file"
}

clean_old_backups() {
  # Keep only the last ROTATE_BACKUPS backups
  local backups
  
  if [[ ! -d "$BACKUP_DIR" ]]; then
    return 0
  fi
  
  backups=$(find "$BACKUP_DIR" -name "node_state_*.json" -type f | sort -r)
  
  local count=0
  while read -r backup; do
    count=$((count + 1))
    
    if [[ $count -gt $ROTATE_BACKUPS ]]; then
      if [[ "$VERBOSE" == true ]]; then
        log_info "Removing old backup: $backup"
      fi
      rm -f "$backup"
    fi
  done <<< "$backups"
}

add_to_array() {
  local key="$1"
  local value="$2"
  
  initialize_state
  
  # Add value to array and ensure uniqueness
  log_info "Adding to array: $key += $value"
  
  # Check if key exists and is an array
  local is_array
  is_array=$(jq ".$key | type == \"array\"" "$STATE_FILE")
  
  if [[ "$is_array" != "true" ]]; then
    # Create empty array if key doesn't exist or isn't an array
    jq --arg key "$key" '. + {($key): []}' "$STATE_FILE" > "${STATE_FILE}.tmp"
    mv "${STATE_FILE}.tmp" "$STATE_FILE"
  fi
  
  # Add value to array if not already present
  jq --arg key "$key" --arg value "$value" \
    '. + {($key): (.[($key)] + [$value] | unique), "lastUpdated": now | todate}' "$STATE_FILE" > "${STATE_FILE}.tmp"
  
  mv "${STATE_FILE}.tmp" "$STATE_FILE"
}

remove_from_array() {
  local key="$1"
  local value="$2"
  
  if [[ ! -f "$STATE_FILE" ]]; then
    log_error "State file not found: $STATE_FILE"
    return 1
  }
  
  # Remove value from array
  log_info "Removing from array: $key -= $value"
  
  # Check if key exists and is an array
  local is_array
  is_array=$(jq ".$key | type == \"array\"" "$STATE_FILE")
  
  if [[ "$is_array" != "true" ]]; then
    log_warn "Key is not an array: $key"
    return 1
  fi
  
  # Remove value from array
  jq --arg key "$key" --arg value "$value" \
    '. + {($key): (.[($key)] - [$value]), "lastUpdated": now | todate}' "$STATE_FILE" > "${STATE_FILE}.tmp"
  
  mv "${STATE_FILE}.tmp" "$STATE_FILE"
}

record_execution() {
  local proposal_id="$1"
  local status="$2"
  local timestamp
  timestamp=$(date --iso-8601=seconds)
  
  # Create JSON for execution record
  local execution_record
  execution_record=$(cat <<EOF
{
  "id": "$proposal_id",
  "status": "$status",
  "timestamp": "$timestamp"
}
EOF
)
  
  # Add to executedProposals array
  jq --argjson record "$execution_record" \
    '. + {"executedProposals": (.executedProposals + [$record]), "lastUpdated": now | todate}' "$STATE_FILE" > "${STATE_FILE}.tmp"
  
  mv "${STATE_FILE}.tmp" "$STATE_FILE"
  
  # Update lastProposalId if needed
  local current_id
  current_id=$(get_state_value "lastProposalId" || echo "0")
  
  if [[ "$proposal_id" =~ ^[0-9]+$ && "$proposal_id" -gt "$current_id" ]]; then
    set_state_value "lastProposalId" "$proposal_id"
  fi
}

main() {
  parse_args "$@"
  
  case "$COMMAND" in
    get)
      get_state_value "$KEY"
      ;;
    set)
      set_state_value "$KEY" "$VALUE"
      ;;
    list)
      list_state
      ;;
    backup)
      backup_state
      ;;
    restore)
      restore_state "$BACKUP_FILE"
      ;;
    clean)
      clean_old_backups
      ;;
    *)
      log_error "Unknown command: $COMMAND"
      print_usage
      exit 1
      ;;
  esac
}

main "$@" 
--- FILE: ./node-ui.sh ---
#!/bin/bash
set -euo pipefail

# ICN Node TUI Interface
# Interactive terminal UI for managing and monitoring ICN nodes

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Default values
NODE_URL="http://localhost:26657"
DATA_DIR="${HOME}/.icn"
LOG_FILE="${DATA_DIR}/logs/node-ui.log"
IDENTITY_PATH="${HOME}/.wallet/identities"
COOP_NAME="default"
TEMP_DIR="/tmp/icn-ui-$$"
REFRESH_INTERVAL=5  # seconds

# Ensure dialog is installed
ensure_dialog() {
  if ! command_exists dialog; then
    log_error "dialog is not installed. Please install it first."
    echo "On Ubuntu/Debian: sudo apt-get install dialog"
    echo "On CentOS/RHEL: sudo yum install dialog"
    echo "On macOS: brew install dialog"
    exit 1
  fi
}

# Create temp directory for UI data
setup_temp() {
  mkdir -p "$TEMP_DIR"
  mkdir -p "$(dirname "$LOG_FILE")"
  # Clean up temp directory on exit
  trap 'rm -rf "$TEMP_DIR"' EXIT
}

# Check if node is running
check_node_running() {
  if ! is_node_running; then
    dialog --title "ICN Node Status" --msgbox "Node is not running! Please start the node first using:\n\n./scripts/daemon.sh start" 10 60
    return 1
  fi
  return 0
}

# Get DAG statistics
get_dag_stats() {
  local stats_file="$TEMP_DIR/dag_stats.txt"
  
  if ! is_node_running; then
    echo "Node is not running" > "$stats_file"
    return 1
  fi
  
  # Get basic node info
  local node_info
  node_info=$(get_node_status 26657 json)
  
  # Extract useful information
  local latest_block_height
  local network
  local node_id
  if command_exists jq; then
    latest_block_height=$(echo "$node_info" | jq -r '.result.sync_info.latest_block_height // "unknown"')
    network=$(echo "$node_info" | jq -r '.result.node_info.network // "unknown"')
    node_id=$(echo "$node_info" | jq -r '.result.node_info.id // "unknown"')
  else
    latest_block_height="unknown (jq not installed)"
    network="unknown (jq not installed)"
    node_id="unknown (jq not installed)"
  fi
  
  # Get DAG stats (using replay-dag.sh)
  local dag_output
  if [[ -x "${SCRIPT_DIR}/replay-dag.sh" ]]; then
    dag_output=$("${SCRIPT_DIR}/replay-dag.sh" --json 2>/dev/null || echo '{"vertices": 0, "proposals": 0, "votes": 0}')
    local vertex_count
    local proposal_count
    local vote_count
    
    if command_exists jq; then
      vertex_count=$(echo "$dag_output" | jq -r '.vertices // 0')
      proposal_count=$(echo "$dag_output" | jq -r '.proposals // 0')
      vote_count=$(echo "$dag_output" | jq -r '.votes // 0')
    else
      vertex_count="unknown (jq not installed)"
      proposal_count="unknown (jq not installed)"
      vote_count="unknown (jq not installed)"
    fi
  else
    vertex_count="unknown (replay-dag.sh not found)"
    proposal_count="unknown (replay-dag.sh not found)"
    vote_count="unknown (replay-dag.sh not found)"
  fi
  
  # Save to file for display
  cat > "$stats_file" <<EOF
Node Status: Running
Network: $network
Node ID: $node_id
Latest Block Height: $latest_block_height
DAG Vertices: $vertex_count
Proposals: $proposal_count
Votes: $vote_count
EOF
}

# Get federation peer information
get_federation_peers() {
  local peers_file="$TEMP_DIR/peers.txt"
  
  if ! is_node_running; then
    echo "Node is not running" > "$peers_file"
    return 1
  fi
  
  # Get net_info from node
  local net_info
  net_info=$(curl -s "$NODE_URL/net_info")
  
  if command_exists jq; then
    local peers
    peers=$(echo "$net_info" | jq -r '.result.peers[] | "\(.node_info.id) - \(.node_info.moniker) (\(.remote_ip):\(.node_info.listen_addr | split(":") | .[2]))"')
    local peers_count
    peers_count=$(echo "$net_info" | jq -r '.result.n_peers')
    
    if [[ -z "$peers" ]]; then
      echo "No peers connected" > "$peers_file"
    else
      echo "Connected Peers: $peers_count" > "$peers_file"
      echo "$peers" >> "$peers_file"
    fi
  else
    echo "Connected peers information not available (jq not installed)" > "$peers_file"
  fi
}

# Get identity information
get_identity_info() {
  local identity_file="$TEMP_DIR/identities.txt"
  
  # Ensure identity directory exists
  if [[ ! -d "$IDENTITY_PATH" ]]; then
    echo "No identities found. Use generate-identity.sh to create one." > "$identity_file"
    return 1
  fi
  
  # List all cooperatives with identities
  local coops=()
  for coop_dir in "$IDENTITY_PATH"/*; do
    if [[ -d "$coop_dir" ]]; then
      coops+=("$(basename "$coop_dir")")
    fi
  done
  
  if [[ ${#coops[@]} -eq 0 ]]; then
    echo "No identities found. Use generate-identity.sh to create one." > "$identity_file"
    return 1
  fi
  
  # Write identity info to file
  echo "Scoped Identities:" > "$identity_file"
  for coop in "${coops[@]}"; do
    echo "Cooperative: $coop" >> "$identity_file"
    
    local found=0
    for identity in "$IDENTITY_PATH/$coop"/*.json; do
      if [[ -f "$identity" ]]; then
        found=1
        local identity_name
        identity_name=$(basename "$identity" .json)
        
        if command_exists jq; then
          local address
          local role
          address=$(jq -r '.address // "unknown"' "$identity")
          role=$(jq -r '.role // "unknown"' "$identity")
          echo "  $identity_name ($role) - $address" >> "$identity_file"
        else
          echo "  $identity_name" >> "$identity_file"
        fi
      fi
    done
    
    if [[ $found -eq 0 ]]; then
      echo "  No identities found" >> "$identity_file"
    fi
    echo "" >> "$identity_file"
  done
}

# Get active proposals
get_active_proposals() {
  local proposals_file="$TEMP_DIR/proposals.txt"
  
  if ! is_node_running; then
    echo "Node is not running" > "$proposals_file"
    return 1
  fi
  
  # Get active proposals using replay-dag.sh
  if [[ -x "${SCRIPT_DIR}/replay-dag.sh" ]]; then
    local proposals_output
    proposals_output=$("${SCRIPT_DIR}/replay-dag.sh" --active-proposals --json 2>/dev/null || echo '[]')
    
    if command_exists jq; then
      if [[ "$proposals_output" == "[]" || -z "$proposals_output" ]]; then
        echo "No active proposals found" > "$proposals_file"
      else
        echo "Active Proposals:" > "$proposals_file"
        echo "$proposals_output" | jq -r '.[] | "ID: \(.id)\nTitle: \(.title)\nStatus: \(.status)\nYes: \(.yes_votes) No: \(.no_votes) Abstain: \(.abstain_votes)\n"' >> "$proposals_file"
      fi
    else
      echo "Proposal information not available (jq not installed)" > "$proposals_file"
    fi
  else
    echo "Proposal information not available (replay-dag.sh not found)" > "$proposals_file"
  fi
}

# Get AgoraNet status
get_agoranet_status() {
  local agoranet_file="$TEMP_DIR/agoranet.txt"
  
  # Check if AgoraNet process is running
  local pid_file="${HOME}/.icn/agoranet.pid"
  if [[ -f "$pid_file" ]]; then
    local pid
    pid=$(cat "$pid_file")
    if ps -p "$pid" > /dev/null; then
      echo "AgoraNet Status: Running (PID: $pid)" > "$agoranet_file"
      
      # Try to get more information from API
      local agoranet_port=8080  # Default port
      if curl -s "http://localhost:${agoranet_port}/api/status" >/dev/null 2>&1; then
        local status_json
        status_json=$(curl -s "http://localhost:${agoranet_port}/api/status")
        
        if command_exists jq; then
          local coop
          local threads
          local users
          coop=$(echo "$status_json" | jq -r '.cooperative // "unknown"')
          threads=$(echo "$status_json" | jq -r '.threads // "0"')
          users=$(echo "$status_json" | jq -r '.users // "0"')
          
          echo "Cooperative: $coop" >> "$agoranet_file"
          echo "Discussion Threads: $threads" >> "$agoranet_file"
          echo "Active Users: $users" >> "$agoranet_file"
        else
          echo "AgoraNet is running, but detailed information not available (jq not installed)" >> "$agoranet_file"
        fi
      else
        echo "AgoraNet API not accessible" >> "$agoranet_file"
      fi
    else
      echo "AgoraNet Status: Not Running (stale PID file)" > "$agoranet_file"
    fi
  else
    echo "AgoraNet Status: Not Running" > "$agoranet_file"
  fi
}

# Refresh all data
refresh_data() {
  get_dag_stats
  get_federation_peers
  get_identity_info
  get_active_proposals
  get_agoranet_status
}

# Display node status
display_node_status() {
  refresh_data
  dialog --title "ICN Node Status" --textbox "$TEMP_DIR/dag_stats.txt" 15 70
}

# Display federation peers
display_federation_peers() {
  get_federation_peers
  dialog --title "Federation Peers" --textbox "$TEMP_DIR/peers.txt" 20 70
}

# Display identity information
display_identities() {
  get_identity_info
  dialog --title "Identity Information" --textbox "$TEMP_DIR/identities.txt" 20 70
}

# Display proposals
display_proposals() {
  get_active_proposals
  dialog --title "Active Proposals" --textbox "$TEMP_DIR/proposals.txt" 20 70
}

# Display AgoraNet status
display_agoranet() {
  get_agoranet_status
  dialog --title "AgoraNet Status" --textbox "$TEMP_DIR/agoranet.txt" 15 70
}

# Create a new identity
create_identity() {
  # Get cooperative name
  local coop
  coop=$(dialog --title "Create Identity" --inputbox "Enter cooperative name:" 8 60 "$COOP_NAME" 3>&1 1>&2 2>&3)
  
  if [[ -z "$coop" ]]; then
    return
  fi
  
  # Get identity name
  local name
  name=$(dialog --title "Create Identity" --inputbox "Enter identity name:" 8 60 "user1" 3>&1 1>&2 2>&3)
  
  if [[ -z "$name" ]]; then
    return
  fi
  
  # Get identity role
  local role
  role=$(dialog --title "Create Identity" --radiolist "Select identity role:" 12 60 3 \
    "member" "Regular member" ON \
    "admin" "Administrative rights" OFF \
    "observer" "Read-only access" OFF 3>&1 1>&2 2>&3)
  
  if [[ -z "$role" ]]; then
    return
  fi
  
  # Create the identity
  dialog --title "Creating Identity" --infobox "Creating identity $name for cooperative $coop with role $role..." 5 70
  
  local output
  output=$("${SCRIPT_DIR}/generate-identity.sh" --name "$name" --coop "$coop" --role "$role" 2>&1)
  local exit_code=$?
  
  if [[ $exit_code -eq 0 ]]; then
    dialog --title "Identity Created" --msgbox "Identity created successfully:\n\n$output" 15 70
  else
    dialog --title "Error" --msgbox "Failed to create identity:\n\n$output" 15 70
  fi
}

# Submit a proposal
submit_proposal() {
  # Check if node is running
  if ! check_node_running; then
    return
  fi
  
  # Get cooperative name
  local coop
  coop=$(dialog --title "Submit Proposal" --inputbox "Enter cooperative name:" 8 60 "$COOP_NAME" 3>&1 1>&2 2>&3)
  
  if [[ -z "$coop" ]]; then
    return
  fi
  
  # Get identity to use
  local identities=()
  local options=()
  
  if [[ -d "$IDENTITY_PATH/$coop" ]]; then
    for identity in "$IDENTITY_PATH/$coop"/*.json; do
      if [[ -f "$identity" ]]; then
        local identity_name
        identity_name=$(basename "$identity" .json)
        identities+=("$identity_name")
        
        if command_exists jq; then
          local role
          role=$(jq -r '.role // "unknown"' "$identity")
          options+=("$identity_name" "$role" OFF)
        else
          options+=("$identity_name" "Unknown role" OFF)
        fi
      fi
    done
  fi
  
  if [[ ${#identities[@]} -eq 0 ]]; then
    dialog --title "Error" --msgbox "No identities found for cooperative $coop. Please create an identity first." 8 60
    return
  fi
  
  # Set the first option to ON
  options[2]="ON"
  
  local identity
  identity=$(dialog --title "Submit Proposal" --radiolist "Select identity to use:" 15 60 8 "${options[@]}" 3>&1 1>&2 2>&3)
  
  if [[ -z "$identity" ]]; then
    return
  fi
  
  # Get proposal title
  local title
  title=$(dialog --title "Submit Proposal" --inputbox "Enter proposal title:" 8 60 "My Proposal" 3>&1 1>&2 2>&3)
  
  if [[ -z "$title" ]]; then
    return
  fi
  
  # Get proposal type
  local proposal_type
  proposal_type=$(dialog --title "Submit Proposal" --radiolist "Select proposal type:" 12 60 3 \
    "TextProposal" "General text proposal" ON \
    "ParameterChange" "Change system parameters" OFF \
    "BudgetAllocation" "Allocate budget" OFF 3>&1 1>&2 2>&3)
  
  if [[ -z "$proposal_type" ]]; then
    return
  fi
  
  # Get proposal description
  local description
  description=$(dialog --title "Submit Proposal" --inputbox "Enter proposal description:" 8 60 "Description of my proposal" 3>&1 1>&2 2>&3)
  
  if [[ -z "$description" ]]; then
    return
  fi
  
  # Submit the proposal
  dialog --title "Submitting Proposal" --infobox "Submitting proposal '$title' with identity $identity..." 5 70
  
  local output
  output=$("${SCRIPT_DIR}/demo-proposals.sh" --scoped-identity "$identity" --coop "$coop" --proposal-title "$title" --proposal-type "$proposal_type" --description "$description" 2>&1)
  local exit_code=$?
  
  if [[ $exit_code -eq 0 ]]; then
    # Extract proposal ID if possible
    local proposal_id
    if command_exists grep; then
      proposal_id=$(echo "$output" | grep -o "Proposal ID: [A-Za-z0-9]*" | sed 's/Proposal ID: //')
      if [[ -n "$proposal_id" ]]; then
        echo "$proposal_id" > "/tmp/icn_last_proposal_id.txt"
      fi
    fi
    
    dialog --title "Proposal Submitted" --msgbox "Proposal submitted successfully:\n\n$output" 15 70
  else
    dialog --title "Error" --msgbox "Failed to submit proposal:\n\n$output" 15 70
  fi
}

# Start AgoraNet
start_agoranet() {
  # Check if node is running
  if ! check_node_running; then
    return
  fi
  
  # Get cooperative name
  local coop
  coop=$(dialog --title "Start AgoraNet" --inputbox "Enter cooperative name:" 8 60 "$COOP_NAME" 3>&1 1>&2 2>&3)
  
  if [[ -z "$coop" ]]; then
    return
  fi
  
  # Get port
  local port
  port=$(dialog --title "Start AgoraNet" --inputbox "Enter port number:" 8 60 "8080" 3>&1 1>&2 2>&3)
  
  if [[ -z "$port" ]]; then
    return
  fi
  
  # Start AgoraNet
  dialog --title "Starting AgoraNet" --infobox "Starting AgoraNet for cooperative $coop on port $port..." 5 70
  
  local output
  output=$("${SCRIPT_DIR}/agoranet-integration.sh" --coop "$coop" --port "$port" --daemon --start 2>&1)
  local exit_code=$?
  
  if [[ $exit_code -eq 0 ]]; then
    dialog --title "AgoraNet Started" --msgbox "AgoraNet started successfully:\n\n$output" 15 70
  else
    dialog --title "Error" --msgbox "Failed to start AgoraNet:\n\n$output" 15 70
  fi
}

# Stop AgoraNet
stop_agoranet() {
  dialog --title "Stopping AgoraNet" --infobox "Stopping AgoraNet..." 5 70
  
  local output
  output=$("${SCRIPT_DIR}/agoranet-integration.sh" --stop 2>&1)
  local exit_code=$?
  
  if [[ $exit_code -eq 0 ]]; then
    dialog --title "AgoraNet Stopped" --msgbox "AgoraNet stopped successfully:\n\n$output" 15 70
  else
    dialog --title "Error" --msgbox "Failed to stop AgoraNet:\n\n$output" 15 70
  fi
}

# View detailed DAG trace
view_dag_trace() {
  # Check if node is running
  if ! check_node_running; then
    return
  fi
  
  local options=()
  
  # Option to view latest DAG state
  options+=("latest" "View latest DAG state" ON)
  
  # Option to view by proposal ID
  options+=("proposal" "View by proposal ID" OFF)
  
  # Option to view by vertex ID
  options+=("vertex" "View by vertex ID" OFF)
  
  local choice
  choice=$(dialog --title "DAG Trace" --radiolist "Select view option:" 12 60 3 "${options[@]}" 3>&1 1>&2 2>&3)
  
  if [[ -z "$choice" ]]; then
    return
  fi
  
  local cmd="${SCRIPT_DIR}/replay-dag.sh"
  local params=""
  
  case "$choice" in
    latest)
      # View latest DAG state
      params=""
      ;;
    proposal)
      # View by proposal ID
      local proposal_id
      
      # Check if we have a saved proposal ID
      if [[ -f "/tmp/icn_last_proposal_id.txt" ]]; then
        local last_id
        last_id=$(cat "/tmp/icn_last_proposal_id.txt")
        proposal_id=$(dialog --title "DAG Trace" --inputbox "Enter proposal ID:" 8 60 "$last_id" 3>&1 1>&2 2>&3)
      else
        proposal_id=$(dialog --title "DAG Trace" --inputbox "Enter proposal ID:" 8 60 "" 3>&1 1>&2 2>&3)
      fi
      
      if [[ -z "$proposal_id" ]]; then
        return
      fi
      
      params="--proposal $proposal_id"
      ;;
    vertex)
      # View by vertex ID
      local vertex_id
      vertex_id=$(dialog --title "DAG Trace" --inputbox "Enter vertex ID:" 8 60 "" 3>&1 1>&2 2>&3)
      
      if [[ -z "$vertex_id" ]]; then
        return
      fi
      
      params="--vertex $vertex_id"
      ;;
  esac
  
  # Run the DAG trace command
  dialog --title "Running DAG Trace" --infobox "Running DAG trace..." 5 70
  
  local output_file="$TEMP_DIR/dag_trace.txt"
  local output
  output=$($cmd $params 2>&1)
  local exit_code=$?
  
  if [[ $exit_code -eq 0 ]]; then
    echo "$output" > "$output_file"
    dialog --title "DAG Trace Result" --textbox "$output_file" 20 78
  else
    dialog --title "Error" --msgbox "Failed to run DAG trace:\n\n$output" 15 70
  fi
}

# Show help information
show_help() {
  dialog --title "ICN Node UI Help" --msgbox "\
ICN Node UI - Interactive terminal interface for ICN nodes

Key features:
- View node and DAG status
- Manage identities
- Submit and track proposals
- Integration with AgoraNet
- Federation peer monitoring

Tips:
- Ensure node is running before using most features
- Use the refresh option to update data
- Identity management requires generate-identity.sh
- Proposal submission requires demo-proposals.sh
- DAG trace requires replay-dag.sh

For more information, visit: https://github.com/your-org/icn-dev-node
" 20 76
}

# Main menu
show_main_menu() {
  while true; do
    local choice
    choice=$(dialog --clear --title "ICN Node UI" --menu "Select an option:" 18 60 10 \
      "1" "Node Status" \
      "2" "Federation Peers" \
      "3" "Identities" \
      "4" "Proposals" \
      "5" "AgoraNet Status" \
      "6" "Create Identity" \
      "7" "Submit Proposal" \
      "8" "Start AgoraNet" \
      "9" "Stop AgoraNet" \
      "10" "DAG Trace" \
      "r" "Refresh Data" \
      "h" "Help" \
      "q" "Quit" 3>&1 1>&2 2>&3)
    
    case $choice in
      1) display_node_status ;;
      2) display_federation_peers ;;
      3) display_identities ;;
      4) display_proposals ;;
      5) display_agoranet ;;
      6) create_identity ;;
      7) submit_proposal ;;
      8) start_agoranet ;;
      9) stop_agoranet ;;
      10) view_dag_trace ;;
      r) refresh_data ;;
      h) show_help ;;
      q) break ;;
      *) ;;
    esac
  done
}

main() {
  ensure_dialog
  setup_temp
  
  # Parse command line arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --node-url)
        NODE_URL="$2"
        shift 2
        ;;
      --coop)
        COOP_NAME="$2"
        shift 2
        ;;
      --help)
        echo "Usage: $(basename "$0") [OPTIONS]"
        echo ""
        echo "Options:"
        echo "  --node-url URL       Node RPC URL (default: http://localhost:26657)"
        echo "  --coop NAME          Default cooperative name (default: default)"
        echo "  --help               Show this help message"
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        echo "Use --help for usage information"
        exit 1
        ;;
    esac
  done
  
  # Start UI
  show_main_menu
}

main "$@" 
--- FILE: ./proposal-trace.sh ---
#!/bin/bash
set -euo pipefail

# ICN Proposal Tracer
# Trace a proposal from creation through voting to execution

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"

# Default values
NODE_URL="http://localhost:26657"
DATA_DIR="${HOME}/.icn"
LOG_FILE="${DATA_DIR}/logs/proposal-trace.log"
PROPOSAL_ID=""
LATEST=false
LIST_PROPOSALS=false
OUTPUT_FORMAT="text"  # text or json
VERBOSE=false

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Trace the full lifecycle of a proposal from creation through voting to execution.

Options:
  --proposal ID        Specific proposal ID to trace
  --latest             Show information about the most recent proposal
  --list               List all proposals in the DAG
  --node-url URL       Node RPC URL (default: http://localhost:26657)
  --json               Output in JSON format
  --verbose            Provide more detailed output
  --help               Display this help message and exit

Examples:
  # Trace a specific proposal
  $(basename "$0") --proposal abc123

  # Show the latest proposal
  $(basename "$0") --latest

  # List all proposals
  $(basename "$0") --list

  # Get detailed JSON output
  $(basename "$0") --proposal abc123 --json --verbose
EOF
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --proposal)
        PROPOSAL_ID="$2"
        shift 2
        ;;
      --latest)
        LATEST=true
        shift
        ;;
      --list)
        LIST_PROPOSALS=true
        shift
        ;;
      --node-url)
        NODE_URL="$2"
        shift 2
        ;;
      --json)
        OUTPUT_FORMAT="json"
        shift
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done
}

validate_args() {
  # Check if the node is running
  if ! curl -s "${NODE_URL}/status" >/dev/null; then
    log_error "Cannot connect to node at ${NODE_URL}"
    exit 1
  fi
  
  # Create log directory
  mkdir -p "$(dirname "$LOG_FILE")"
  
  # Validate arguments
  if [[ -z "$PROPOSAL_ID" && "$LATEST" == false && "$LIST_PROPOSALS" == false ]]; then
    log_error "You must specify either --proposal, --latest, or --list"
    print_usage
    exit 1
  fi
}

# Get a list of all proposals
list_all_proposals() {
  log_info "Listing all proposals in the DAG"
  
  if [[ ! -x "${SCRIPT_DIR}/replay-dag.sh" ]]; then
    log_error "replay-dag.sh script not found or not executable"
    exit 1
  fi
  
  local output
  if [[ "$OUTPUT_FORMAT" == "json" ]]; then
    output=$("${SCRIPT_DIR}/replay-dag.sh" --proposals --json)
    echo "$output"
  else
    output=$("${SCRIPT_DIR}/replay-dag.sh" --proposals)
    
    if [[ "$VERBOSE" == true ]]; then
      echo "$output"
    else
      # Extract just the list of proposals
      echo "$output" | grep -A 1 "ID:" | grep -v "^--$"
    fi
  fi
}

# Get the latest proposal
get_latest_proposal() {
  log_info "Getting the latest proposal"
  
  if [[ ! -x "${SCRIPT_DIR}/replay-dag.sh" ]]; then
    log_error "replay-dag.sh script not found or not executable"
    exit 1
  fi
  
  local proposals_output
  proposals_output=$("${SCRIPT_DIR}/replay-dag.sh" --proposals --json 2>/dev/null || echo '[]')
  
  if [[ "$proposals_output" == "[]" || -z "$proposals_output" ]]; then
    log_error "No proposals found in the DAG"
    exit 1
  fi
  
  # Extract the latest proposal ID
  if command_exists jq; then
    local latest_id
    latest_id=$(echo "$proposals_output" | jq -r 'sort_by(.timestamp) | reverse | .[0].id')
    
    if [[ -z "$latest_id" || "$latest_id" == "null" ]]; then
      log_error "Failed to extract latest proposal ID"
      exit 1
    fi
    
    PROPOSAL_ID="$latest_id"
    log_info "Latest proposal ID: $PROPOSAL_ID"
  else
    log_error "jq is required to process the latest proposal"
    exit 1
  fi
}

# Trace a specific proposal
trace_proposal() {
  log_info "Tracing proposal: $PROPOSAL_ID"
  
  if [[ ! -x "${SCRIPT_DIR}/replay-dag.sh" ]]; then
    log_error "replay-dag.sh script not found or not executable"
    exit 1
  fi
  
  # Get proposal details
  local proposal_output
  proposal_output=$("${SCRIPT_DIR}/replay-dag.sh" --proposal "$PROPOSAL_ID" --json 2>/dev/null)
  local exit_code=$?
  
  if [[ $exit_code -ne 0 || -z "$proposal_output" ]]; then
    log_error "Failed to get details for proposal $PROPOSAL_ID"
    exit 1
  fi
  
  # Process proposal data
  if [[ "$OUTPUT_FORMAT" == "json" ]]; then
    # For JSON output, we'll build a more comprehensive object
    if command_exists jq; then
      # Extract basic proposal info
      local proposal_basic
      proposal_basic=$(echo "$proposal_output" | jq -c '.proposal')
      
      # Get the proposal vertex
      local proposal_vertex
      proposal_vertex=$("${SCRIPT_DIR}/replay-dag.sh" --vertex-by-proposal "$PROPOSAL_ID" --json 2>/dev/null || echo '{}')
      
      # Get all votes for this proposal
      local votes
      votes=$("${SCRIPT_DIR}/replay-dag.sh" --votes-for-proposal "$PROPOSAL_ID" --json 2>/dev/null || echo '[]')
      
      # Get execution result if any
      local execution
      execution=$("${SCRIPT_DIR}/replay-dag.sh" --execution-for-proposal "$PROPOSAL_ID" --json 2>/dev/null || echo '{}')
      
      # Combine all data
      local result
      result=$(jq -n \
        --argjson proposal "$proposal_basic" \
        --argjson vertex "$proposal_vertex" \
        --argjson votes "$votes" \
        --argjson execution "$execution" \
        '{
          proposal: $proposal,
          vertex: $vertex,
          votes: $votes,
          execution: $execution,
          trace_timestamp: "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"
        }')
      
      echo "$result"
    else
      log_error "jq is required for JSON output"
      exit 1
    fi
  else
    # For text output, format a readable report
    format_text_report "$proposal_output"
  fi
}

# Format a human-readable text report
format_text_report() {
  local proposal_json="$1"
  
  if ! command_exists jq; then
    echo "$proposal_json"
    return
  fi
  
  # Extract proposal details
  local id
  local title
  local description
  local type
  local status
  local proposer
  local submitted_time
  local voting_end_time
  local yes_votes
  local no_votes
  local abstain_votes
  local total_votes
  local quorum
  local vertex_id
  
  id=$(echo "$proposal_json" | jq -r '.proposal.id')
  title=$(echo "$proposal_json" | jq -r '.proposal.title')
  description=$(echo "$proposal_json" | jq -r '.proposal.description')
  type=$(echo "$proposal_json" | jq -r '.proposal.type')
  status=$(echo "$proposal_json" | jq -r '.proposal.status')
  proposer=$(echo "$proposal_json" | jq -r '.proposal.proposer')
  submitted_time=$(echo "$proposal_json" | jq -r '.proposal.submitted_time')
  voting_end_time=$(echo "$proposal_json" | jq -r '.proposal.voting_end_time')
  yes_votes=$(echo "$proposal_json" | jq -r '.proposal.yes_votes')
  no_votes=$(echo "$proposal_json" | jq -r '.proposal.no_votes')
  abstain_votes=$(echo "$proposal_json" | jq -r '.proposal.abstain_votes')
  total_votes=$(echo "$proposal_json" | jq -r '.proposal.total_votes')
  quorum=$(echo "$proposal_json" | jq -r '.proposal.quorum')
  vertex_id=$(echo "$proposal_json" | jq -r '.proposal.vertex_id // "unknown"')
  
  # Print report header
  cat <<EOF
=============================================
PROPOSAL TRACE REPORT
=============================================
ID:             $id
Title:          $title
Type:           $type
Status:         $status
Proposer:       $proposer
Submitted:      $submitted_time
Voting Ends:    $voting_end_time
DAG Vertex ID:  $vertex_id

DESCRIPTION:
$description

VOTING SUMMARY:
Yes:      $yes_votes
No:       $no_votes
Abstain:  $abstain_votes
Total:    $total_votes
Quorum:   $quorum
---------------------------------------------
EOF
  
  # Get votes
  local votes
  votes=$("${SCRIPT_DIR}/replay-dag.sh" --votes-for-proposal "$id" --json 2>/dev/null || echo '[]')
  
  if [[ "$votes" != "[]" ]]; then
    echo "VOTES:"
    # Sort votes by timestamp
    echo "$votes" | jq -r 'sort_by(.timestamp) | .[] | "\(.timestamp): \(.voter) - \(.decision)"'
  else
    echo "VOTES: None recorded"
  fi
  
  # Get execution details if available
  if [[ "$status" == "passed" || "$status" == "executed" ]]; then
    local execution
    execution=$("${SCRIPT_DIR}/replay-dag.sh" --execution-for-proposal "$id" --json 2>/dev/null || echo '{}')
    
    if [[ "$execution" != "{}" ]]; then
      local execution_time
      local executor
      local success
      local result
      
      execution_time=$(echo "$execution" | jq -r '.timestamp // "unknown"')
      executor=$(echo "$execution" | jq -r '.executor // "unknown"')
      success=$(echo "$execution" | jq -r '.success // "unknown"')
      result=$(echo "$execution" | jq -r '.result // "unknown"')
      
      cat <<EOF

EXECUTION:
Time:     $execution_time
Executor: $executor
Success:  $success
Result:   $result
EOF
    else
      echo -e "\nEXECUTION: Not executed yet"
    fi
  fi
  
  # Show DAG path for verbose mode
  if [[ "$VERBOSE" == true ]]; then
    echo -e "\nDAG PATH:"
    # Get the DAG path from proposal to execution
    "${SCRIPT_DIR}/replay-dag.sh" --dag-path-for-proposal "$id" || echo "DAG path not available"
  fi
  
  echo "============================================="
}

main() {
  parse_args "$@"
  validate_args
  
  if [[ "$LIST_PROPOSALS" == true ]]; then
    list_all_proposals
  elif [[ "$LATEST" == true ]]; then
    get_latest_proposal
    trace_proposal
  elif [[ -n "$PROPOSAL_ID" ]]; then
    trace_proposal
  fi
}

main "$@" 
--- FILE: ./register-dns.sh ---
#!/bin/bash

# ICN Node DNS and DID Registration
# This script handles DNS registration for .icn domains and DID document creation

set -e

# Default values
COOP_NAME=""
DNS_SERVERS=("ns1.icn-federation.org" "ns2.icn-federation.org")
DID_REGISTRY="$HOME/.icn-node/did-registry"
WALLET_DIR="$HOME/.wallet/identities"
OUTPUT_DIR="$HOME/.icn-node/dns"
FORCE=false
VERBOSE=false

# ANSI color codes
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Print header
echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}    ICN DNS and DID Registration      ${NC}"
echo -e "${BLUE}======================================${NC}"

# Function to show usage
show_usage() {
  echo "Usage: $0 [OPTIONS]"
  echo ""
  echo "Options:"
  echo "  --coop NAME         Cooperative name to register (required)"
  echo "  --admin-key PATH    Path to admin identity key (default: auto-detected)"
  echo "  --dns-servers LIST  Comma-separated list of DNS servers (default: ns1/ns2.icn-federation.org)"
  echo "  --ip-address IP     Public IP address for this node (default: auto-detected)"
  echo "  --output DIR        Output directory for DNS and DID documents (default: ~/.icn-node/dns)"
  echo "  --force             Force overwrite of existing registration"
  echo "  --verbose           Enable verbose logging"
  echo "  --help              Show this help message"
  echo ""
  echo "Examples:"
  echo "  $0 --coop mycoop --ip-address 203.0.113.42"
  echo "  $0 --coop federation-xyz --dns-servers ns1.example.com,ns2.example.com"
  exit 1
}

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --coop)
      COOP_NAME="$2"
      shift 2
      ;;
    --admin-key)
      ADMIN_KEY="$2"
      shift 2
      ;;
    --dns-servers)
      IFS=',' read -ra DNS_SERVERS <<< "$2"
      shift 2
      ;;
    --ip-address)
      IP_ADDRESS="$2"
      shift 2
      ;;
    --output)
      OUTPUT_DIR="$2"
      shift 2
      ;;
    --force)
      FORCE=true
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --help)
      show_usage
      ;;
    *)
      echo -e "${RED}Unknown option: $1${NC}"
      show_usage
      ;;
  esac
done

# Ensure a cooperative name is provided
if [[ -z "$COOP_NAME" ]]; then
  echo -e "${YELLOW}No cooperative name specified. Using interactive mode.${NC}"
  echo -e "${YELLOW}Enter cooperative name:${NC}"
  read -r COOP_NAME
  
  if [[ -z "$COOP_NAME" ]]; then
    echo -e "${RED}Error: Cooperative name is required.${NC}"
    exit 1
  fi
fi

# Create output directory if it doesn't exist
if [[ ! -d "$OUTPUT_DIR" ]]; then
  echo -e "${YELLOW}Output directory does not exist at: $OUTPUT_DIR${NC}"
  echo -e "${YELLOW}Creating directory...${NC}"
  mkdir -p "$OUTPUT_DIR"
fi

# Create DID registry directory if it doesn't exist
if [[ ! -d "$DID_REGISTRY" ]]; then
  echo -e "${YELLOW}DID registry directory does not exist at: $DID_REGISTRY${NC}"
  echo -e "${YELLOW}Creating directory...${NC}"
  mkdir -p "$DID_REGISTRY"
fi

# Auto-detect IP address if not provided
if [[ -z "$IP_ADDRESS" ]]; then
  echo -e "${YELLOW}Auto-detecting IP address...${NC}"
  # Try various methods to get the public IP
  if command -v curl &> /dev/null; then
    IP_ADDRESS=$(curl -s https://api.ipify.org)
  elif command -v wget &> /dev/null; then
    IP_ADDRESS=$(wget -qO- https://api.ipify.org)
  else
    echo -e "${RED}Error: Could not auto-detect IP address. Please specify with --ip-address.${NC}"
    exit 1
  fi
  echo -e "${GREEN}Detected IP address: $IP_ADDRESS${NC}"
fi

# Auto-detect admin key if not provided
if [[ -z "$ADMIN_KEY" ]]; then
  echo -e "${YELLOW}Auto-detecting admin identity...${NC}"
  ADMIN_DIR="$WALLET_DIR/$COOP_NAME"
  
  if [[ ! -d "$ADMIN_DIR" ]]; then
    echo -e "${RED}Error: No identities found for cooperative $COOP_NAME.${NC}"
    echo -e "${YELLOW}Generate identities first using:${NC}"
    echo -e "${YELLOW}  ./scripts/generate-identity.sh --name admin --coop \"$COOP_NAME\" --role admin${NC}"
    exit 1
  fi
  
  # Look for admin identity
  ADMIN_FILES=$(find "$ADMIN_DIR" -name "*.json" -exec grep -l "admin" {} \;)
  if [[ -z "$ADMIN_FILES" ]]; then
    echo -e "${RED}Error: No admin identity found for cooperative $COOP_NAME.${NC}"
    exit 1
  fi
  
  # Use the first admin identity
  ADMIN_KEY=$(echo "$ADMIN_FILES" | head -n 1)
  echo -e "${GREEN}Found admin identity: $ADMIN_KEY${NC}"
fi

# Generate DNS registration
echo -e "${GREEN}Generating DNS registration for ${COOP_NAME}.icn${NC}"

DNS_FILE="$OUTPUT_DIR/${COOP_NAME}.icn.zone"
if [[ -f "$DNS_FILE" ]] && [[ "$FORCE" != true ]]; then
  echo -e "${RED}DNS zone file already exists: $DNS_FILE${NC}"
  echo -e "${YELLOW}Use --force to overwrite.${NC}"
  exit 1
fi

# Create DNS zone file
cat > "$DNS_FILE" << EOF
; Zone file for ${COOP_NAME}.icn
; Generated by register-dns.sh on $(date)
\$ORIGIN ${COOP_NAME}.icn.
\$TTL 3600

@       IN      SOA     ${DNS_SERVERS[0]}. admin.${COOP_NAME}.icn. (
                        $(date +%Y%m%d%H) ; Serial
                        3600        ; Refresh
                        1800        ; Retry
                        604800      ; Expire
                        86400 )     ; Minimum TTL

; Name servers
@       IN      NS      ${DNS_SERVERS[0]}.
@       IN      NS      ${DNS_SERVERS[1]}.

; A records
@       IN      A       $IP_ADDRESS
node    IN      A       $IP_ADDRESS
api     IN      A       $IP_ADDRESS

; Service records
_icn._tcp       IN      SRV     10 10 26656 node.${COOP_NAME}.icn.
_agoranet._tcp  IN      SRV     10 10 7654  api.${COOP_NAME}.icn.
EOF

echo -e "${GREEN}DNS zone file created: $DNS_FILE${NC}"

# Generate DID document
echo -e "${GREEN}Generating DID document for did:icn:${COOP_NAME}${NC}"

DID_FILE="$OUTPUT_DIR/did_icn_${COOP_NAME}.json"
if [[ -f "$DID_FILE" ]] && [[ "$FORCE" != true ]]; then
  echo -e "${RED}DID document already exists: $DID_FILE${NC}"
  echo -e "${YELLOW}Use --force to overwrite.${NC}"
  exit 1
fi

# Extract public key from admin identity
if [[ ! -f "$ADMIN_KEY" ]]; then
  echo -e "${RED}Error: Admin key file not found: $ADMIN_KEY${NC}"
  exit 1
fi

# For now, just use a placeholder public key value
# In a real implementation, this would extract the actual key from the identity file
PUB_KEY_ID="z6MkrzX9gpLTwihJxPw7rHM3kn1WTQrMjCKiHquY4meShR9Q"

# Create DID document
cat > "$DID_FILE" << EOF
{
  "@context": [
    "https://www.w3.org/ns/did/v1",
    "https://w3id.org/security/suites/ed25519-2020/v1"
  ],
  "id": "did:icn:${COOP_NAME}",
  "verificationMethod": [{
    "id": "did:icn:${COOP_NAME}#z6MkrzX9gpLTwihJxPw7rHM3kn1WTQrMjCKiHquY4meShR9Q",
    "type": "Ed25519VerificationKey2020",
    "controller": "did:icn:${COOP_NAME}",
    "publicKeyMultibase": "${PUB_KEY_ID}"
  }],
  "authentication": [
    "did:icn:${COOP_NAME}#z6MkrzX9gpLTwihJxPw7rHM3kn1WTQrMjCKiHquY4meShR9Q"
  ],
  "assertionMethod": [
    "did:icn:${COOP_NAME}#z6MkrzX9gpLTwihJxPw7rHM3kn1WTQrMjCKiHquY4meShR9Q"
  ],
  "service": [
    {
      "id": "did:icn:${COOP_NAME}#node",
      "type": "ICNNode",
      "serviceEndpoint": "node.${COOP_NAME}.icn:26656"
    },
    {
      "id": "did:icn:${COOP_NAME}#agoranet",
      "type": "AgoraNetDeliberation",
      "serviceEndpoint": "api.${COOP_NAME}.icn:7654"
    }
  ]
}
EOF

echo -e "${GREEN}DID document created: $DID_FILE${NC}"

# Register DID in the local registry
DID_REGISTRY_FILE="$DID_REGISTRY/did_registry.json"

# Create or update the registry
if [[ ! -f "$DID_REGISTRY_FILE" ]]; then
  echo -e "${YELLOW}Creating new DID registry at: $DID_REGISTRY_FILE${NC}"
  echo '{"dids":{}}' > "$DID_REGISTRY_FILE"
fi

# In a real implementation, this would use jq to properly update the JSON
# For now, just notify about the registration
echo -e "${GREEN}DID 'did:icn:${COOP_NAME}' registered in local registry${NC}"

# Submit to DAG using demo-proposals.sh (simulated)
echo -e "${YELLOW}Do you want to submit this registration to the DAG?${NC} [Yes/No]"
read -r submit_to_dag
if [[ "$submit_to_dag" =~ ^[Yy][Ee][Ss]$ ]] || [[ "$submit_to_dag" =~ ^[Yy]$ ]]; then
  echo -e "${YELLOW}Submitting registration to DAG...${NC}"
  
  # In a real implementation, this would actually submit to the DAG
  # For now, just simulate it
  echo -e "${GREEN}Registration submitted to DAG!${NC}"
  echo -e "${GREEN}Your cooperative is now accessible at:${NC}"
  echo -e "${BLUE}  - DNS: ${COOP_NAME}.icn${NC}"
  echo -e "${BLUE}  - DID: did:icn:${COOP_NAME}${NC}"
  echo -e "${BLUE}  - Node: node.${COOP_NAME}.icn:26656${NC}"
  echo -e "${BLUE}  - API: api.${COOP_NAME}.icn:7654${NC}"
fi

echo -e "${GREEN}Registration process complete!${NC}"
echo -e "${YELLOW}NOTE: For actual DNS resolution, submit the zone file to the ICN federation DNS authorities.${NC}"
echo -e "${BLUE}======================================${NC}" 
--- FILE: ./replay-dag.sh ---
#!/usr/bin/env bash
set -euo pipefail

# Default settings
OUTPUT_FORMAT="tree"  # Options: raw, json, tree
NODE_URL="http://localhost:26657"
PROPOSAL_ID=""
VERTEX_ID=""
DAG_PATH=""
RELEASE_MODE=false
VERBOSE=false
NODE_BINARY=""

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --raw)
      OUTPUT_FORMAT="raw"
      shift
      ;;
    --json)
      OUTPUT_FORMAT="json"
      shift
      ;;
    --tree)
      OUTPUT_FORMAT="tree"
      shift
      ;;
    --proposal)
      PROPOSAL_ID="$2"
      shift 2
      ;;
    --vertex)
      VERTEX_ID="$2"
      shift 2
      ;;
    --node-url)
      NODE_URL="$2"
      shift 2
      ;;
    --dag-path)
      DAG_PATH="$2"
      shift 2
      ;;
    --release)
      RELEASE_MODE=true
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --help)
      echo "Usage: $0 [options]"
      echo "Replay and trace DAG state and proposals"
      echo ""
      echo "Options:"
      echo "  --raw                Output raw data (minimal formatting)"
      echo "  --json               Output JSON formatted data"
      echo "  --tree               Output tree-structured data (default)"
      echo "  --proposal <id>      Trace a specific proposal by ID"
      echo "  --vertex <id>        Trace a specific vertex and its relationships"
      echo "  --node-url <url>     Node RPC URL (default: http://localhost:26657)"
      echo "  --dag-path <path>    Custom path to DAG data (for offline analysis)"
      echo "  --release            Use release build of icn-node"
      echo "  --verbose            Show detailed output"
      echo "  --help               Show this help message"
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      echo "Run '$0 --help' for usage information"
      exit 1
      ;;
  esac
done

# Load environment variables if .env exists
if [[ -f ../.env ]]; then
  # shellcheck disable=SC1091
  source ../.env
fi

# Check for required tools
check_dependencies() {
  local missing=false

  if ! command -v curl &> /dev/null; then
    echo "❌ 'curl' is required but not found"
    missing=true
  fi
  
  if ! command -v jq &> /dev/null; then
    echo "❌ 'jq' is required but not found"
    missing=true
  fi
  
  if [[ "$missing" = true ]]; then
    echo "Please install missing dependencies"
    exit 1
  fi
}

# Function to check if the node binary exists
check_node_binary() {
  local binary_path
  if [[ "$RELEASE_MODE" = true ]]; then
    binary_path="../deps/icn-covm/target/release/icn-node"
  else
    binary_path="../deps/icn-covm/target/debug/icn-node"
  fi

  if [[ ! -f "$binary_path" ]]; then
    echo "❌ Node binary not found at $binary_path"
    echo "Please run install.sh first or check that the build completed successfully."
    exit 1
  fi

  NODE_BINARY="$binary_path"
  
  if [[ "$VERBOSE" = true ]]; then
    echo "✅ Using node binary: $NODE_BINARY"
  fi
}

# Check if node is running
check_node_running() {
  # Skip if we're using a local DAG path
  if [[ -n "$DAG_PATH" ]]; then
    if [[ ! -d "$DAG_PATH" ]]; then
      echo "❌ DAG path not found: $DAG_PATH"
      exit 1
    fi
    return 0
  fi

  if ! curl -s "$NODE_URL/health" > /dev/null; then
    echo "❌ Node is not running at $NODE_URL"
    echo "Please start a node first with './run-node.sh'"
    exit 1
  fi
  
  if [[ "$VERBOSE" = true ]]; then
    echo "✅ Node is running at $NODE_URL"
  fi
}

# Get general DAG info
get_dag_info() {
  echo "Fetching DAG information..."
  
  local dag_info
  
  if [[ -n "$DAG_PATH" ]]; then
    # Use offline mode with local DAG path
    dag_info=$("$NODE_BINARY" dag info --path "$DAG_PATH" --format json)
  else
    # Use online mode with RPC
    dag_info=$(curl -s "$NODE_URL/dag_info")
  fi
  
  case "$OUTPUT_FORMAT" in
    raw)
      echo "$dag_info"
      ;;
    json)
      echo "$dag_info" | jq .
      ;;
    tree)
      echo "DAG Summary:"
      echo "$dag_info" | jq '.result.dag_info | {
        vertex_count: .vertex_count,
        root_count: .root_count,
        tip_count: .tip_count,
        genesis_time: .genesis_time,
        latest_update: .latest_update
      }'
      echo -e "\nLatest Tips:"
      echo "$dag_info" | jq -r '.result.dag_info.tips[] | " - \(.id): \(.summary // "No summary")"' 2>/dev/null || echo "No tips found"
      ;;
  esac
}

# Trace a specific proposal
trace_proposal() {
  echo "Tracing proposal: $PROPOSAL_ID"
  
  local proposal_data
  
  if [[ -n "$DAG_PATH" ]]; then
    # Use offline mode with local DAG path
    proposal_data=$("$NODE_BINARY" proposal show "$PROPOSAL_ID" --path "$DAG_PATH" --format json)
  else
    # Use online mode with RPC
    proposal_data=$(curl -s "$NODE_URL/abci_query?path=\"/custom/gov/proposal/$PROPOSAL_ID\"")
  fi
  
  case "$OUTPUT_FORMAT" in
    raw)
      echo "$proposal_data"
      ;;
    json)
      echo "$proposal_data" | jq .
      ;;
    tree)
      echo "Proposal Details:"
      # Extract proposal details from response
      if [[ -n "$DAG_PATH" ]]; then
        # Parse directly when using CLI (which gives cleaner output)
        echo "$proposal_data" | jq '{
          id: .id,
          title: .title,
          description: .description,
          status: .status,
          proposer: .proposer,
          submitted_at: .submitted_at,
          voting_end_time: .voting_end_time, 
          final_tally: .final_tally
        }'
      else
        # Parse from RPC response (more complex extraction)
        echo "$proposal_data" | jq -r '.result.response.value | @base64d | fromjson | {
          id: .id,
          title: .title,
          description: .description,
          status: .status,
          proposer: .proposer,
          submitted_at: .submitted_at,
          voting_end_time: .voting_end_time,
          final_tally: .final_tally
        }' 2>/dev/null || echo "Could not parse proposal data"
      fi
      
      # Fetch votes for this proposal
      echo -e "\nVotes:"
      local votes_data
      
      if [[ -n "$DAG_PATH" ]]; then
        # Use offline mode with local DAG path
        votes_data=$("$NODE_BINARY" proposal votes "$PROPOSAL_ID" --path "$DAG_PATH" --format json)
      else
        # Use online mode with RPC
        votes_data=$(curl -s "$NODE_URL/abci_query?path=\"/custom/gov/votes/$PROPOSAL_ID\"")
      fi
      
      # Process votes data
      if [[ -n "$DAG_PATH" ]]; then
        echo "$votes_data" | jq 'map({voter: .voter, vote: .option, time: .time})' 2>/dev/null || 
          echo "No votes found"
      else
        echo "$votes_data" | jq -r '.result.response.value | @base64d | fromjson | map({
          voter: .voter, 
          vote: .option, 
          time: .time
        })' 2>/dev/null || echo "No votes found"
      fi
      
      # Show proposal lifecycle events
      echo -e "\nProposal Lifecycle:"
      echo "  Submission → Discussion → Voting → Execution"
      ;;
  esac
}

# Trace a specific vertex and its relationships
trace_vertex() {
  echo "Tracing vertex: $VERTEX_ID"
  
  local vertex_data
  
  if [[ -n "$DAG_PATH" ]]; then
    # Use offline mode with local DAG path
    vertex_data=$("$NODE_BINARY" dag vertex "$VERTEX_ID" --path "$DAG_PATH" --format json)
  else
    # Use online mode with RPC
    vertex_data=$(curl -s "$NODE_URL/dag_vertex?id=$VERTEX_ID")
  fi
  
  case "$OUTPUT_FORMAT" in
    raw)
      echo "$vertex_data"
      ;;
    json)
      echo "$vertex_data" | jq .
      ;;
    tree)
      echo "Vertex Details:"
      
      if [[ -n "$DAG_PATH" ]]; then
        # Parse directly when using CLI
        echo "$vertex_data" | jq '{
          id: .id,
          timestamp: .timestamp,
          parents: .parents,
          children: .children,
          height: .height,
          proposer: .proposer,
          data_type: .data_type,
          scope: .scope
        }'
      else
        # Parse from RPC response
        echo "$vertex_data" | jq '.result.vertex | {
          id: .id,
          timestamp: .timestamp,
          parents: .parents,
          children: .children,
          height: .height,
          proposer: .proposer,
          data_type: .data_type,
          scope: .scope
        }' 2>/dev/null || echo "Could not parse vertex data"
      fi
      
      # Get ancestry
      echo -e "\nAncestry:"
      
      if [[ -n "$DAG_PATH" ]]; then
        # Use offline mode with local DAG path
        "$NODE_BINARY" dag ancestors "$VERTEX_ID" --path "$DAG_PATH" --format json | 
          jq 'map({id: .id, height: .height, data_type: .data_type})' 2>/dev/null || echo "No ancestry data"
      else
        # Use online mode with RPC
        curl -s "$NODE_URL/dag_ancestors?id=$VERTEX_ID" | 
          jq '.result.ancestors | map({id: .id, height: .height, data_type: .data_type})' 2>/dev/null || echo "No ancestry data"
      fi
      
      # Get descendants
      echo -e "\nDescendants:"
      
      if [[ -n "$DAG_PATH" ]]; then
        # Use offline mode with local DAG path
        "$NODE_BINARY" dag descendants "$VERTEX_ID" --path "$DAG_PATH" --format json | 
          jq 'map({id: .id, height: .height, data_type: .data_type})' 2>/dev/null || echo "No descendant data"
      else
        # Use online mode with RPC
        curl -s "$NODE_URL/dag_descendants?id=$VERTEX_ID" | 
          jq '.result.descendants | map({id: .id, height: .height, data_type: .data_type})' 2>/dev/null || echo "No descendant data"
      fi
      ;;
  esac
}

# Main script execution
main() {
  echo "ICN DAG Trace & Replay Tool"
  
  # Specific vertex tracing
  if [[ -n "$VERTEX_ID" ]]; then
    trace_vertex
    exit 0
  fi
  
  # Specific proposal tracing
  if [[ -n "$PROPOSAL_ID" ]]; then
    trace_proposal
    exit 0
  fi
  
  # Default action: general DAG info
  get_dag_info
}

# Execute script
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$script_dir"

check_dependencies
check_node_binary
check_node_running
main 
--- FILE: ./run-agoranet.sh ---
#!/bin/bash

# AgoraNet Service Runner
# This script starts the AgoraNet deliberation service as a long-running process

set -e

# Default values
PORT=7654
DAG_PATH="$HOME/.icn-node/dag"
COOP_NAME=""
VERBOSE=false
DAEMON=false
LOG_FILE="$HOME/.icn-node/agoranet.log"
API_ENABLED=true

# ANSI color codes
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Print header
echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}       AgoraNet Service Runner        ${NC}"
echo -e "${BLUE}======================================${NC}"

# Function to show usage
show_usage() {
  echo "Usage: $0 [OPTIONS]"
  echo ""
  echo "Options:"
  echo "  --coop NAME         Cooperative name to associate with this AgoraNet instance"
  echo "  --port PORT         API port to listen on (default: 7654)"
  echo "  --dag-path PATH     Path to ICN DAG directory (default: ~/.icn-node/dag)"
  echo "  --daemon            Run as a background daemon"
  echo "  --log-file FILE     Log file when running as daemon (default: ~/.icn-node/agoranet.log)"
  echo "  --no-api            Disable API server"
  echo "  --verbose           Enable verbose logging"
  echo "  --help              Show this help message"
  echo ""
  echo "Examples:"
  echo "  $0 --coop mycoop --port 8000"
  echo "  $0 --coop federation-xyz --daemon"
  exit 1
}

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --coop)
      COOP_NAME="$2"
      shift 2
      ;;
    --port)
      PORT="$2"
      shift 2
      ;;
    --dag-path)
      DAG_PATH="$2"
      shift 2
      ;;
    --daemon)
      DAEMON=true
      shift
      ;;
    --log-file)
      LOG_FILE="$2"
      shift 2
      ;;
    --no-api)
      API_ENABLED=false
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --help)
      show_usage
      ;;
    *)
      echo -e "${RED}Unknown option: $1${NC}"
      show_usage
      ;;
  esac
done

# Ensure a cooperative name is provided
if [[ -z "$COOP_NAME" ]]; then
  echo -e "${YELLOW}No cooperative name specified. Using interactive mode.${NC}"
  echo -e "${YELLOW}Enter cooperative name:${NC}"
  read -r COOP_NAME
  
  if [[ -z "$COOP_NAME" ]]; then
    echo -e "${RED}Error: Cooperative name is required.${NC}"
    exit 1
  fi
fi

# Check if DAG path exists
if [[ ! -d "$DAG_PATH" ]]; then
  echo -e "${YELLOW}DAG directory does not exist at: $DAG_PATH${NC}"
  echo -e "${YELLOW}Creating directory...${NC}"
  mkdir -p "$DAG_PATH"
fi

# Function to start AgoraNet service
start_agoranet() {
  echo -e "${GREEN}Starting AgoraNet service for cooperative: $COOP_NAME${NC}"
  echo -e "${GREEN}DAG Path: $DAG_PATH${NC}"
  
  if [[ "$API_ENABLED" = true ]]; then
    echo -e "${GREEN}API Server: Enabled on port $PORT${NC}"
  else
    echo -e "${GREEN}API Server: Disabled${NC}"
  fi
  
  # Create a PID file to track the process
  PID_FILE="/tmp/agoranet-$COOP_NAME.pid"
  
  # Check if already running
  if [[ -f "$PID_FILE" ]]; then
    PID=$(cat "$PID_FILE")
    if ps -p "$PID" > /dev/null; then
      echo -e "${YELLOW}AgoraNet service for $COOP_NAME is already running with PID: $PID${NC}"
      echo -e "${YELLOW}To restart, kill the existing process or use --restart flag.${NC}"
      exit 0
    else
      echo -e "${YELLOW}Found stale PID file. Cleaning up...${NC}"
      rm "$PID_FILE"
    fi
  fi
  
  # Start the service
  if [[ "$DAEMON" = true ]]; then
    echo -e "${GREEN}Running as daemon, logging to: $LOG_FILE${NC}"
    
    # Use demo-proposals.sh as a base for now, will be replaced with actual AgoraNet daemon
    # In a real implementation, this would start a proper background service
    {
      echo "--- AgoraNet Service Started at $(date) ---"
      echo "Cooperative: $COOP_NAME"
      echo "API Port: $PORT"
      echo "DAG Path: $DAG_PATH"
      
      # Call demo-proposals as a placeholder for the real AgoraNet service
      if [[ "$API_ENABLED" = true ]]; then
        echo "Starting API server on port $PORT..."
        echo "This is a placeholder for the actual AgoraNet API server"
        
        # Simulate an API server with netcat (if available)
        if command -v nc &> /dev/null; then
          echo "HTTP/1.1 200 OK" > /tmp/agoranet-response.http
          echo "Content-Type: application/json" >> /tmp/agoranet-response.http
          echo "" >> /tmp/agoranet-response.http
          echo "{\"status\":\"running\",\"cooperative\":\"$COOP_NAME\",\"uptime\":0}" >> /tmp/agoranet-response.http
          
          # Don't actually start this in production - just a demo
          # while true; do nc -l -p $PORT < /tmp/agoranet-response.http; done
        fi
      fi
      
      # Execute the demo-proposals script in the background
      ./scripts/demo-proposals.sh --no-start --coop "$COOP_NAME" --monitor
      
      echo "--- AgoraNet Service Stopped at $(date) ---"
    } > "$LOG_FILE" 2>&1 &
    
    # Save the PID
    echo $! > "$PID_FILE"
    echo -e "${GREEN}AgoraNet service started with PID: $(cat "$PID_FILE")${NC}"
    echo -e "${GREEN}To check logs: tail -f $LOG_FILE${NC}"
    echo -e "${GREEN}To stop: kill $(cat "$PID_FILE") && rm $PID_FILE${NC}"
  else
    # Interactive mode
    echo -e "${GREEN}Running in interactive mode...${NC}"
    echo -e "${GREEN}Press Ctrl+C to stop${NC}"
    
    # Call demo-proposals.sh as a placeholder for the real AgoraNet service
    ./scripts/demo-proposals.sh --no-start --coop "$COOP_NAME" --verbose
    
    echo -e "${GREEN}AgoraNet service stopped.${NC}"
  fi
}

# Start the service
start_agoranet

echo -e "${BLUE}======================================${NC}"
if [[ "$DAEMON" = true ]]; then
  echo -e "${GREEN}AgoraNet service is running in the background.${NC}"
else
  echo -e "${GREEN}AgoraNet service has completed.${NC}"
fi 
--- FILE: ./run-node.sh ---
#!/usr/bin/env bash
set -euo pipefail

# Default settings
RELEASE_MODE=false
LOG_LEVEL="info"
NODE_NAME="local-node-$(date +%s)"
DATA_DIR="$HOME/.icn-node"
CONFIG_FILE="../config/dev-config.toml"
FEDERATION_ENABLED=true
STORAGE_ENABLED=true

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --release)
      RELEASE_MODE=true
      shift
      ;;
    --log-level)
      LOG_LEVEL="$2"
      shift 2
      ;;
    --node-name)
      NODE_NAME="$2"
      shift 2
      ;;
    --data-dir)
      DATA_DIR="$2"
      shift 2
      ;;
    --config)
      CONFIG_FILE="$2"
      shift 2
      ;;
    --no-federation)
      FEDERATION_ENABLED=false
      shift
      ;;
    --no-storage)
      STORAGE_ENABLED=false
      shift
      ;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--release] [--log-level <level>] [--node-name <n>] [--data-dir <dir>] [--config <file>] [--no-federation] [--no-storage]"
      exit 1
      ;;
  esac
done

# Load environment variables if .env exists
if [[ -f ../.env ]]; then
  # shellcheck disable=SC1091
  source ../.env
fi

# Function to check if the node binary exists
check_node_binary() {
  local binary_path
  if [[ "$RELEASE_MODE" = true ]]; then
    binary_path="../target/release/icn-node"
  else
    binary_path="../target/debug/icn-node"
  fi

  if [[ ! -f "$binary_path" ]]; then
    echo "❌ Node binary not found at $binary_path"
    echo "Please run 'cargo build' first or check that the build completed successfully."
    exit 1
  fi

  echo "✅ Node binary found at $binary_path"
  echo "NODE_BINARY=$binary_path"
  export NODE_BINARY="$binary_path"
}

# Create data directory if it doesn't exist
create_data_dir() {
  if [[ ! -d "$DATA_DIR" ]]; then
    echo "Creating data directory at $DATA_DIR..."
    mkdir -p "$DATA_DIR"
  fi
}

# Initialize the node if needed
init_node() {
  if [[ ! -d "$DATA_DIR/config" ]]; then
    echo "Initializing node with name '$NODE_NAME'..."
    "$NODE_BINARY" init --home "$DATA_DIR" --moniker "$NODE_NAME"
    
    # Apply custom configuration if config file exists
    if [[ -f "$CONFIG_FILE" ]]; then
      echo "Applying custom configuration from $CONFIG_FILE..."
      cp "$CONFIG_FILE" "$DATA_DIR/config/config.toml"
    fi
  else
    echo "Node already initialized at $DATA_DIR"
  fi
}

# Start the node
start_node() {
  local federation_flag=""
  local storage_flag=""
  
  if [[ "$FEDERATION_ENABLED" = true ]]; then
    federation_flag="--federation"
  fi
  
  if [[ "$STORAGE_ENABLED" = true ]]; then
    storage_flag="--storage"
  fi
  
  echo "Starting ICN node with integrated CoVM..."
  echo "  - Name: $NODE_NAME"
  echo "  - Data directory: $DATA_DIR"
  echo "  - Federation enabled: $FEDERATION_ENABLED"
  echo "  - Storage enabled: $STORAGE_ENABLED"
  echo "  - Log level: $LOG_LEVEL"
  
  # shellcheck disable=SC2086
  "$NODE_BINARY" start --home "$DATA_DIR" $federation_flag $storage_flag --log-level "$LOG_LEVEL"
}

# Main script execution
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$script_dir"

check_node_binary
create_data_dir
init_node
start_node 
--- FILE: ./setup-covm.sh ---
#!/bin/bash
set -e

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Path variables
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
DEV_NODE_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
COVM_REPO="$DEV_NODE_DIR/../icn-covm"
DEPS_DIR="$DEV_NODE_DIR/deps"
TARGET_DIR="$DEPS_DIR/icn-covm"
COVM_VERSION_FILE="$DEV_NODE_DIR/.covm-version"

# Ensure we're in the right directory structure
cd "$DEV_NODE_DIR"

if [ ! -f Cargo.toml ]; then
  echo -e "${RED}Error: Not in icn-dev-node root. Please run this script from the repository root.${NC}"
  exit 1
fi

# Check if COVM repository exists
if [ ! -d "$COVM_REPO" ] || [ ! -d "$COVM_REPO/.git" ]; then
  echo -e "${RED}Error: icn-covm repository not found at $COVM_REPO${NC}"
  echo -e "Please clone the CoVM repository:"
  echo -e "  git clone <covm-repo-url> $COVM_REPO"
  exit 1
fi

# Get current CoVM commit hash
cd "$COVM_REPO"
CURRENT_COVM_COMMIT=$(git rev-parse HEAD)
COVM_CHANGES=$(git status --porcelain)

# Check for uncommitted changes in CoVM
if [ -n "$COVM_CHANGES" ]; then
  echo -e "${YELLOW}Warning: icn-covm repository has uncommitted changes.${NC}"
  echo -e "If this is intentional for development, you can proceed."
  echo -e "Run ${YELLOW}git status${NC} in the CoVM repository to see changes."
fi

# Return to the node directory
cd "$DEV_NODE_DIR"

# Check if .covm-version exists and compare
if [ -f "$COVM_VERSION_FILE" ]; then
  VERSION_COMMIT=$(cat "$COVM_VERSION_FILE")
  if [ "$VERSION_COMMIT" != "$CURRENT_COVM_COMMIT" ]; then
    echo -e "${YELLOW}⚠️ Warning: Local CoVM commit does not match .covm-version.${NC}"
    echo -e "Current CoVM commit: ${YELLOW}$CURRENT_COVM_COMMIT${NC}"
    echo -e "Expected version:    ${YELLOW}$VERSION_COMMIT${NC}"
    echo -e "If you're testing new changes, this is fine."
  else
    echo -e "${GREEN}✓ CoVM commit matches .covm-version file.${NC}"
  fi
fi

# Remove existing copy if it exists
if [ -e "$TARGET_DIR" ]; then
  echo "Removing existing icn-covm in deps directory..."
  rm -rf "$TARGET_DIR"
fi

# Create deps directory if it doesn't exist
mkdir -p "$DEPS_DIR"

# Copy CoVM repository (create a fresh copy)
echo "Creating a copy of icn-covm repository..."
cp -r "$COVM_REPO" "$TARGET_DIR"

# Check if the copy was successful
if [ -d "$TARGET_DIR" ] && [ -d "$TARGET_DIR/crates/icn-covm" ]; then
  echo -e "${GREEN}✓ Successfully copied CoVM for development!${NC}"
  echo -e "Changes made to ${YELLOW}$COVM_REPO${NC} will be available in the node after running this script again."
  echo ""
  echo -e "To build and test with the current CoVM, run: ${GREEN}cargo build -p icn-node${NC}"
else
  echo -e "${RED}Failed to copy CoVM repository!${NC}"
  exit 1
fi

# Optionally update .covm-version with current commit
if [ ! -f "$COVM_VERSION_FILE" ] || [ -n "$COVM_CHANGES" ]; then
  echo ""
  echo -e "${YELLOW}Note:${NC} If you want to lock to this version of CoVM, run:"
  echo -e "  echo $CURRENT_COVM_COMMIT > .covm-version"
fi

echo -e "${GREEN}Setup complete!${NC}" 
--- FILE: ./simulate-coop.sh ---
#!/usr/bin/env bash
set -euo pipefail

# Default settings
COOP_NAME="sim-coop-$(date +%s)"
IDENTITY_COUNT=3
GOVERNANCE_MACRO="proposal_lifecycle"
REPLAY=false
RELEASE_MODE=false
VERBOSE=false
NODE_RUNNING=false
DATA_DIR="$HOME/.icn-node"
NODE_URL="http://localhost:26657"
NODE_BINARY=""

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --coop)
      COOP_NAME="$2"
      shift 2
      ;;
    --identity-count)
      IDENTITY_COUNT="$2"
      if ! [[ "$IDENTITY_COUNT" =~ ^[0-9]+$ ]] || [ "$IDENTITY_COUNT" -lt 2 ]; then
        echo "❌ Identity count must be a number >= 2"
        exit 1
      fi
      shift 2
      ;;
    --governance-macro)
      GOVERNANCE_MACRO="$2"
      shift 2
      ;;
    --replay)
      REPLAY=true
      shift
      ;;
    --data-dir)
      DATA_DIR="$2"
      shift 2
      ;;
    --node-url)
      NODE_URL="$2"
      shift 2
      ;;
    --release)
      RELEASE_MODE=true
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --help)
      echo "Usage: $0 [options]"
      echo "Simulate a cooperative with multiple identities and governance flows"
      echo ""
      echo "Options:"
      echo "  --coop <name>             Cooperative name (default: sim-coop-timestamp)"
      echo "  --identity-count <number> Number of identities to create (default: 3, min: 2)"
      echo "  --governance-macro <name> Governance macro to run (default: proposal_lifecycle)"
      echo "  --replay                  Replay and display DAG after simulation"
      echo "  --data-dir <dir>          Node data directory (default: $HOME/.icn-node)"
      echo "  --node-url <url>          Node RPC URL (default: http://localhost:26657)"
      echo "  --release                 Use release build of icn-node"
      echo "  --verbose                 Show detailed output"
      echo "  --help                    Show this help message"
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      echo "Run '$0 --help' for usage information"
      exit 1
      ;;
  esac
done

# Load environment variables if .env exists
if [[ -f ../.env ]]; then
  # shellcheck disable=SC1091
  source ../.env
fi

# Check for required tools
check_dependencies() {
  local missing=false

  if ! command -v curl &> /dev/null; then
    echo "❌ 'curl' is required but not found"
    missing=true
  fi
  
  if ! command -v jq &> /dev/null; then
    echo "❌ 'jq' is required but not found"
    missing=true
  fi
  
  if [[ "$missing" = true ]]; then
    echo "Please install missing dependencies"
    exit 1
  fi
}

# Function to check if the node binary exists
check_node_binary() {
  local binary_path
  if [[ "$RELEASE_MODE" = true ]]; then
    binary_path="../deps/icn-covm/target/release/icn-node"
  else
    binary_path="../deps/icn-covm/target/debug/icn-node"
  fi

  if [[ ! -f "$binary_path" ]]; then
    echo "❌ Node binary not found at $binary_path"
    echo "Please run install.sh first or check that the build completed successfully."
    exit 1
  fi

  NODE_BINARY="$binary_path"
  
  if [[ "$VERBOSE" = true ]]; then
    echo "✅ Using node binary: $NODE_BINARY"
  fi
}

# Check if node is running
check_node_running() {
  if curl -s "$NODE_URL/health" > /dev/null; then
    NODE_RUNNING=true
    echo "✅ Node is running at $NODE_URL"
  else
    echo "⚠️ Node is not running at $NODE_URL"
    echo "Starting a local node..."
    ./run-node.sh --data-dir "$DATA_DIR" &
    NODE_PID=$!
    
    # Wait for node to start
    echo "Waiting for node to start..."
    local max_attempts=30
    local attempts=0
    while ! curl -s "$NODE_URL/health" > /dev/null && [[ $attempts -lt $max_attempts ]]; do
      sleep 1
      ((attempts++))
      echo -n "."
    done
    
    if [[ $attempts -lt $max_attempts ]]; then
      echo -e "\n✅ Node started successfully"
      NODE_RUNNING=true
    else
      echo -e "\n❌ Failed to start node"
      exit 1
    fi
  fi
}

# Create identities for the cooperative
create_identities() {
  echo "Creating $IDENTITY_COUNT identities for cooperative '$COOP_NAME'..."
  
  # Create admin identity
  echo "Creating admin identity..."
  ./generate-identity.sh --name "admin" --coop "$COOP_NAME" --role "admin" --output "../.wallet/identities"
  
  # Create member identities
  for ((i=1; i<IDENTITY_COUNT; i++)); do
    echo "Creating member$i identity..."
    ./generate-identity.sh --name "member$i" --coop "$COOP_NAME" --role "member" --output "../.wallet/identities"
  done
  
  echo "✅ Created $IDENTITY_COUNT identities for cooperative '$COOP_NAME'"
}

# Create governance proposal
create_proposal() {
  echo "Creating governance proposal using '$GOVERNANCE_MACRO' macro..."
  
  # Path to macro template
  local macro_path="../deps/icn-covm/templates/macros/$GOVERNANCE_MACRO.dsl"
  
  # Check if the macro template exists, if not create a simple one
  if [[ ! -f "$macro_path" ]]; then
    echo "⚠️ Macro template not found: $macro_path"
    echo "Creating a simple proposal template..."
    
    # Create the templates directory if it doesn't exist
    mkdir -p "../deps/icn-covm/templates/macros"
    
    # Create a simple proposal template
    cat > "$macro_path" << EOF
proposal {
  title: "Test Proposal for $COOP_NAME",
  description: "This is an automatically generated test proposal for the $COOP_NAME cooperative.",
  scope: "$COOP_NAME",
  voting_period: "30s",
  
  action: {
    type: "text",
    data: "This is a test proposal with no executable actions."
  }
}
EOF
    echo "✅ Created simple proposal template at $macro_path"
  fi
  
  # Get admin identity path
  local admin_identity="../.wallet/identities/$COOP_NAME/admin.json"
  
  # Submit the proposal
  echo "Submitting proposal as admin..."
  
  if [[ "$VERBOSE" = true ]]; then
    echo "Executing: $NODE_BINARY tx gov submit-proposal --from-macro $macro_path --identity $admin_identity --chain-id icn-local --home $DATA_DIR"
  fi
  
  local proposal_output
  proposal_output=$("$NODE_BINARY" tx gov submit-proposal \
                    --from-macro "$macro_path" \
                    --identity "$admin_identity" \
                    --chain-id "icn-local" \
                    --home "$DATA_DIR" \
                    --yes 2>&1)
  
  # Extract proposal ID
  local proposal_id
  proposal_id=$(echo "$proposal_output" | grep -o 'proposal_id: "[^"]*"' | cut -d'"' -f2)
  
  if [[ -z "$proposal_id" ]]; then
    echo "❌ Failed to extract proposal ID"
    if [[ "$VERBOSE" = true ]]; then
      echo "Proposal output: $proposal_output"
    fi
    exit 1
  fi
  
  echo "✅ Proposal created with ID: $proposal_id"
  echo "$proposal_id" > "/tmp/icn_last_proposal_id.txt"
  
  # Wait for the proposal to be visible in the DAG
  echo "Waiting for proposal to be indexed..."
  sleep 3
  
  return 0
}

# Vote on proposal
vote_on_proposal() {
  # Get last proposal ID
  local proposal_id
  proposal_id=$(cat "/tmp/icn_last_proposal_id.txt")
  
  if [[ -z "$proposal_id" ]]; then
    echo "❌ No proposal ID found"
    exit 1
  fi
  
  echo "Voting on proposal $proposal_id..."
  
  # Start from index 1 to skip admin (who created the proposal)
  for ((i=1; i<IDENTITY_COUNT; i++)); do
    local member_identity="../.wallet/identities/$COOP_NAME/member$i.json"
    
    # Determine vote (make it interesting by having some yes/no votes)
    local vote="yes"
    if (( i % 3 == 0 )); then
      vote="no"
    fi
    
    echo "Member$i voting $vote..."
    
    if [[ "$VERBOSE" = true ]]; then
      echo "Executing: $NODE_BINARY tx gov vote $proposal_id $vote --identity $member_identity --chain-id icn-local --home $DATA_DIR"
    fi
    
    "$NODE_BINARY" tx gov vote \
      "$proposal_id" "$vote" \
      --identity "$member_identity" \
      --chain-id "icn-local" \
      --home "$DATA_DIR" \
      --yes
  done
  
  echo "✅ All members have voted on the proposal"
  
  # Wait for votes to be processed
  echo "Waiting for votes to be processed..."
  sleep 5
}

# Replay and show results
replay_results() {
  # Get last proposal ID
  local proposal_id
  proposal_id=$(cat "/tmp/icn_last_proposal_id.txt")
  
  if [[ -z "$proposal_id" ]]; then
    echo "❌ No proposal ID found"
    exit 1
  fi
  
  echo "Replaying DAG state for proposal $proposal_id..."
  
  # Use the replay-dag.sh script to show detailed proposal information
  ./replay-dag.sh --proposal "$proposal_id" --tree
  
  echo "Simulation completed successfully!"
}

# Main function to run the simulation
run_simulation() {
  echo "Starting cooperative simulation..."
  echo "  - Cooperative: $COOP_NAME"
  echo "  - Identities: $IDENTITY_COUNT"
  echo "  - Governance Macro: $GOVERNANCE_MACRO"
  
  create_identities
  create_proposal
  vote_on_proposal
  
  if [[ "$REPLAY" = true ]]; then
    replay_results
  fi
  
  echo "Simulation completed!"
}

# Main script execution
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$script_dir"

check_dependencies
check_node_binary
check_node_running
run_simulation 
--- FILE: ./systemd/icn-node.service ---
[Unit]
Description=ICN Node Service
After=network.target
Documentation=https://github.com/your-org/icn-dev-node

[Service]
Type=forking
User=%i
Group=%i
WorkingDirectory=/home/%i/icn-dev-node
ExecStart=/home/%i/icn-dev-node/scripts/daemon.sh start
ExecStop=/home/%i/icn-dev-node/scripts/daemon.sh stop
Restart=on-failure
RestartSec=30
PIDFile=/home/%i/.icn/node.pid
LimitNOFILE=65536
StandardOutput=append:/home/%i/.icn/logs/service.log
StandardError=append:/home/%i/.icn/logs/service.log

# Security options
ProtectSystem=full
PrivateTmp=true
NoNewPrivileges=true

[Install]
WantedBy=multi-user.target 
--- FILE: ./systemd/install-service.sh ---
#!/bin/bash
set -euo pipefail

# Install the ICN Node systemd service

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/../common.sh"

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Install the ICN Node as a systemd service.

Options:
  --user USER           User to run the service as (default: current user)
  --node-type TYPE      Node type: 'dev', 'testnet', or 'livenet' (default: dev)
  --data-dir DIR        Data directory (default: ~/.icn)
  --auto-register       Automatically register DNS and DID
  --no-federation       Disable federation
  --no-storage          Disable storage
  --help                Display this help message and exit

Example:
  $(basename "$0") --user alice --node-type testnet --auto-register
EOF
}

# Default values
SERVICE_USER="$(whoami)"
NODE_TYPE="dev"
DATA_DIR="${HOME}/.icn"
AUTO_REGISTER=false
FEDERATION=true
STORAGE=true

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --user)
        SERVICE_USER="$2"
        shift 2
        ;;
      --node-type)
        NODE_TYPE="$2"
        shift 2
        ;;
      --data-dir)
        DATA_DIR="$2"
        shift 2
        ;;
      --auto-register)
        AUTO_REGISTER=true
        shift
        ;;
      --no-federation)
        FEDERATION=false
        shift
        ;;
      --no-storage)
        STORAGE=false
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done
}

validate_args() {
  if [[ ! "$NODE_TYPE" =~ ^(dev|testnet|livenet)$ ]]; then
    log_error "Node type must be 'dev', 'testnet', or 'livenet'"
    exit 1
  fi
  
  if ! id "$SERVICE_USER" &>/dev/null; then
    log_error "User '$SERVICE_USER' does not exist"
    exit 1
  fi
}

install_service() {
  if ! is_root; then
    log_error "This script must be run as root to install the systemd service"
    exit 1
  }
  
  log_info "Installing ICN Node systemd service for user '$SERVICE_USER'..."
  
  # Copy service file to systemd directory
  local service_name="icn-node@${SERVICE_USER}.service"
  local service_path="/etc/systemd/system/${service_name}"
  
  cp "${SCRIPT_DIR}/icn-node.service" "$service_path"
  
  # Create the daemon config file
  local user_home
  user_home=$(eval echo "~${SERVICE_USER}")
  local config_dir="${user_home}/.icn/config"
  mkdir -p "$config_dir"
  
  local daemon_config="${config_dir}/daemon.conf"
  cat > "$daemon_config" <<EOF
# ICN Node Daemon Configuration
# Created on $(date)

# Node type: dev, testnet, or livenet
NODE_TYPE="${NODE_TYPE}"

# Data directory
DATA_DIR="${DATA_DIR}"

# Auto-register DNS and DID
AUTO_REGISTER=${AUTO_REGISTER}

# Enable federation
FEDERATION=${FEDERATION}

# Enable storage
STORAGE=${STORAGE}
EOF

  # Set proper permissions
  chown -R "${SERVICE_USER}:${SERVICE_USER}" "$(dirname "$daemon_config")"
  
  # Reload systemd and enable service
  systemctl daemon-reload
  systemctl enable "$service_name"
  
  log_info "Service installed successfully as $service_name"
  log_info "You can now start it with: sudo systemctl start $service_name"
}

main() {
  parse_args "$@"
  validate_args
  install_service
}

main "$@" 
--- FILE: ./template-registry.sh ---
#!/bin/bash
set -euo pipefail

# ICN Template Registry Script
# Manages a repository of DSL templates for common operations

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
source "${SCRIPT_DIR}/common.sh"
source "${SCRIPT_DIR}/node-state.sh"

# Default values
DATA_DIR="${HOME}/.icn"
TEMPLATES_DIR="${DATA_DIR}/templates"
QUEUE_DIR="${DATA_DIR}/queue"
DEFAULT_TEMPLATES_DIR="${SCRIPT_DIR}/../templates"
TEMPLATE_NAME=""
TEMPLATE_OUTPUT=""
VERBOSE=false
LIST_ONLY=false
SHOW_CONTENT=false
APPLY_TEMPLATE=false
FORCE=false
CUSTOM_VARS=()

print_usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS] [COMMAND]

Manage DSL templates for common ICN operations.

Commands:
  list                   List available templates
  show TEMPLATE          Show contents of a specific template
  add PATH [NAME]        Add a new template from a file
  apply TEMPLATE [OUT]   Apply a template to create a new DSL file
  remove TEMPLATE        Remove a template from the registry

Options:
  --data-dir DIR         Data directory (default: ${DATA_DIR})
  --templates-dir DIR    Templates directory (default: ${DATA_DIR}/templates)
  --output FILE          Output file for applied template
  --queue                Queue the generated file for execution
  --var KEY=VALUE        Set a custom variable for template substitution
  --force                Force overwrite existing files
  --verbose              Enable verbose output
  --help                 Display this help message and exit

Examples:
  # List all available templates
  $(basename "$0") list

  # Show the contents of a template
  $(basename "$0") show governance/proposal

  # Add a custom template
  $(basename "$0") add my_template.dsl governance/custom

  # Apply a template with variables
  $(basename "$0") apply governance/proposal --var title="Add new peer" --var peer_id="QmHash"
  
  # Apply a template and queue for execution
  $(basename "$0") apply governance/vote --var vote="yes" --queue
EOF
}

parse_args() {
  local command=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --data-dir)
        DATA_DIR="$2"
        TEMPLATES_DIR="${DATA_DIR}/templates"
        QUEUE_DIR="${DATA_DIR}/queue"
        shift 2
        ;;
      --templates-dir)
        TEMPLATES_DIR="$2"
        shift 2
        ;;
      --output)
        TEMPLATE_OUTPUT="$2"
        shift 2
        ;;
      --queue)
        APPLY_TEMPLATE=true
        shift
        ;;
      --var)
        CUSTOM_VARS+=("$2")
        shift 2
        ;;
      --force)
        FORCE=true
        shift
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --help)
        print_usage
        exit 0
        ;;
      list)
        LIST_ONLY=true
        shift
        ;;
      show)
        SHOW_CONTENT=true
        if [[ $# -gt 1 && ! "$2" =~ ^-- ]]; then
          TEMPLATE_NAME="$2"
          shift 2
        else
          log_error "Template name required for 'show' command"
          print_usage
          exit 1
        fi
        ;;
      add)
        command="add"
        if [[ $# -gt 1 && ! "$2" =~ ^-- ]]; then
          local template_path="$2"
          shift 2
          
          # Optional template name parameter
          if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
            TEMPLATE_NAME="$1"
            shift
          else
            # Use filename without extension as template name
            TEMPLATE_NAME=$(basename "$template_path" .dsl)
          fi
          
          # Save for later use by command
          TEMPLATE_OUTPUT="$template_path"
        else
          log_error "Template path required for 'add' command"
          print_usage
          exit 1
        fi
        ;;
      apply)
        command="apply"
        APPLY_TEMPLATE=true
        if [[ $# -gt 1 && ! "$2" =~ ^-- ]]; then
          TEMPLATE_NAME="$2"
          shift 2
          
          # Optional output file
          if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
            TEMPLATE_OUTPUT="$1"
            shift
          fi
        else
          log_error "Template name required for 'apply' command"
          print_usage
          exit 1
        fi
        ;;
      remove)
        command="remove"
        if [[ $# -gt 1 && ! "$2" =~ ^-- ]]; then
          TEMPLATE_NAME="$2"
          shift 2
        else
          log_error "Template name required for 'remove' command"
          print_usage
          exit 1
        fi
        ;;
      -*)
        log_error "Unknown option: $1"
        print_usage
        exit 1
        ;;
      *)
        log_error "Unknown command: $1"
        print_usage
        exit 1
        ;;
    esac
  done

  # Set default action if none specified
  if [[ -z "$command" && "$LIST_ONLY" == false && "$SHOW_CONTENT" == false ]]; then
    LIST_ONLY=true
  fi

  return 0
}

validate_args() {
  # Create necessary directories
  mkdir -p "$TEMPLATES_DIR" "$QUEUE_DIR"

  # If we're listing, showing, or applying a template, make sure templates dir exists
  if [[ "$LIST_ONLY" == true || "$SHOW_CONTENT" == true || "$APPLY_TEMPLATE" == true ]]; then
    if [[ ! -d "$TEMPLATES_DIR" ]]; then
      log_error "Templates directory not found: $TEMPLATES_DIR"
      return 1
    fi
  fi

  # If showing or applying, make sure template name is provided
  if [[ "$SHOW_CONTENT" == true || "$APPLY_TEMPLATE" == true ]]; then
    if [[ -z "$TEMPLATE_NAME" ]]; then
      log_error "Template name is required"
      return 1
    fi
  fi

  return 0
}

# Initialize the template registry with default templates if not present
initialize_templates() {
  if [[ ! -d "$DEFAULT_TEMPLATES_DIR" ]]; then
    log_warn "Default templates directory not found: $DEFAULT_TEMPLATES_DIR"
    return 1
  fi

  # Check if templates directory is empty
  if [[ -z "$(ls -A "$TEMPLATES_DIR" 2>/dev/null)" ]]; then
    log_info "Initializing template registry with default templates"
    
    # Copy default templates
    cp -r "$DEFAULT_TEMPLATES_DIR"/* "$TEMPLATES_DIR"
    
    log_success "Initialized template registry with default templates"
  fi

  return 0
}

# List all available templates
list_templates() {
  log_info "Available templates:"
  
  # Find all .dsl files in the templates directory
  local count=0
  local templates=()
  
  while IFS= read -r -d '' template; do
    # Get relative path from templates directory
    local rel_path="${template#$TEMPLATES_DIR/}"
    # Remove .dsl extension
    local template_name="${rel_path%.dsl}"
    templates+=("$template_name")
    ((count++))
  done < <(find "$TEMPLATES_DIR" -name "*.dsl" -type f -print0 | sort -z)
  
  # Print templates in columns with descriptions
  if [[ ${#templates[@]} -eq 0 ]]; then
    echo "No templates found."
    return 0
  fi
  
  # Print templates in a nice format
  printf "%-30s %-50s\n" "NAME" "DESCRIPTION"
  echo "----------------------------------------------------------------------"
  
  for template in "${templates[@]}"; do
    local description=""
    local template_file="${TEMPLATES_DIR}/${template}.dsl"
    
    # Extract description from first comment line
    if [[ -f "$template_file" ]]; then
      description=$(head -n 5 "$template_file" | grep -E '^#' | head -n 1 | sed 's/^#\s*//')
      # Truncate description if too long
      if [[ ${#description} -gt 50 ]]; then
        description="${description:0:47}..."
      fi
    fi
    
    printf "%-30s %-50s\n" "$template" "$description"
  done
  
  echo
  log_info "Found $count templates"
  
  return 0
}

# Show content of a template
show_template() {
  local template_name="$1"
  local template_file="${TEMPLATES_DIR}/${template_name}.dsl"
  
  if [[ ! -f "$template_file" ]]; then
    log_error "Template not found: $template_name"
    return 1
  fi
  
  log_info "Template: $template_name"
  echo "-------------------------------------------------------"
  
  # Show template content
  cat "$template_file"
  
  echo "-------------------------------------------------------"
  
  # Extract variables from template for help
  local variables=()
  while IFS= read -r line; do
    # Match {{VARIABLE}} patterns
    local vars=$(echo "$line" | grep -o '{{[A-Za-z0-9_]\+}}' | sed 's/{{//g' | sed 's/}}//g')
    if [[ -n "$vars" ]]; then
      for var in $vars; do
        # Add to array if not already present
        if [[ ! " ${variables[*]} " =~ " ${var} " ]]; then
          variables+=("$var")
        fi
      done
    fi
  done < "$template_file"
  
  # Show variable info if found
  if [[ ${#variables[@]} -gt 0 ]]; then
    echo
    log_info "Template variables:"
    for var in "${variables[@]}"; do
      echo "  - $var"
    done
  fi
  
  return 0
}

# Add a new template
add_template() {
  local source_path="$1"
  local template_name="$2"
  local target_file="${TEMPLATES_DIR}/${template_name}.dsl"
  
  if [[ ! -f "$source_path" ]]; then
    log_error "Source file not found: $source_path"
    return 1
  fi
  
  # Create target directory if needed
  mkdir -p "$(dirname "$target_file")"
  
  # Check if template already exists
  if [[ -f "$target_file" && "$FORCE" != true ]]; then
    log_error "Template already exists: $template_name"
    log_error "Use --force to overwrite"
    return 1
  fi
  
  # Copy template file
  cp "$source_path" "$target_file"
  
  log_success "Added template: $template_name"
  
  return 0
}

# Remove a template
remove_template() {
  local template_name="$1"
  local template_file="${TEMPLATES_DIR}/${template_name}.dsl"
  
  if [[ ! -f "$template_file" ]]; then
    log_error "Template not found: $template_name"
    return 1
  fi
  
  # Ask for confirmation unless force is enabled
  if [[ "$FORCE" != true ]]; then
    read -r -p "Are you sure you want to remove template '$template_name'? [y/N] " response
    if [[ ! "${response,,}" =~ ^y(es)?$ ]]; then
      log_info "Template removal cancelled"
      return 0
    fi
  fi
  
  # Remove the template
  rm "$template_file"
  
  log_success "Removed template: $template_name"
  
  return 0
}

# Apply a template with variable substitution
apply_template() {
  local template_name="$1"
  local output_file="$2"
  local template_file="${TEMPLATES_DIR}/${template_name}.dsl"
  
  if [[ ! -f "$template_file" ]]; then
    log_error "Template not found: $template_name"
    return 1
  fi
  
  # If no output file specified, generate one
  if [[ -z "$output_file" ]]; then
    # Get proposal ID from state for naming
    local proposal_id
    proposal_id=$(node_state get lastProposalId 2>/dev/null)
    
    # Increment proposal ID or use default
    if [[ -z "$proposal_id" || "$proposal_id" == "null" ]]; then
      proposal_id=1
    else
      proposal_id=$((proposal_id + 1))
    fi
    
    # Update proposal ID in state
    node_state set lastProposalId "$proposal_id"
    
    # Create output filename
    local template_basename=$(basename "$template_name")
    output_file="${QUEUE_DIR}/proposal_${proposal_id}_pending.dsl"
  fi
  
  # Check if output file already exists
  if [[ -f "$output_file" && "$FORCE" != true ]]; then
    log_error "Output file already exists: $output_file"
    log_error "Use --force to overwrite"
    return 1
  fi
  
  # Create output directory if needed
  mkdir -p "$(dirname "$output_file")"
  
  # Read template file
  local template_content
  template_content=$(cat "$template_file")
  
  # Extract variables from template
  local variables=()
  while IFS= read -r line; do
    # Match {{VARIABLE}} patterns
    local vars=$(echo "$line" | grep -o '{{[A-Za-z0-9_]\+}}' | sed 's/{{//g' | sed 's/}}//g')
    if [[ -n "$vars" ]]; then
      for var in $vars; do
        # Add to array if not already present
        if [[ ! " ${variables[*]} " =~ " ${var} " ]]; then
          variables+=("$var")
        fi
      done
    fi
  done < "$template_file"
  
  # Process each custom variable
  declare -A var_values
  for custom_var in "${CUSTOM_VARS[@]}"; do
    # Split KEY=VALUE
    IFS='=' read -r key value <<< "$custom_var"
    var_values["$key"]="$value"
  done
  
  # Ask for values of variables not provided
  for var in "${variables[@]}"; do
    if [[ -z "${var_values[$var]:-}" ]]; then
      read -r -p "Enter value for $var: " value
      var_values["$var"]="$value"
    fi
  done
  
  # Apply substitutions
  local output_content="$template_content"
  for var in "${!var_values[@]}"; do
    local value="${var_values[$var]}"
    # Escape special characters in value for sed
    value="${value//\\/\\\\}"
    value="${value//&/\\&}"
    value="${value//\//\\/}"
    
    # Substitute variable
    output_content=$(echo "$output_content" | sed "s/{{$var}}/$value/g")
  done
  
  # Write to output file
  echo "$output_content" > "$output_file"
  
  log_success "Applied template to: $output_file"
  
  return 0
}

main() {
  parse_args "$@"
  
  if ! validate_args; then
    exit 1
  fi
  
  # Initialize templates if needed
  initialize_templates
  
  # Execute the requested command
  if [[ "$LIST_ONLY" == true ]]; then
    list_templates
  elif [[ "$SHOW_CONTENT" == true ]]; then
    show_template "$TEMPLATE_NAME"
  elif [[ "$APPLY_TEMPLATE" == true ]]; then
    apply_template "$TEMPLATE_NAME" "$TEMPLATE_OUTPUT"
  elif [[ "$TEMPLATE_NAME" != "" && "$TEMPLATE_OUTPUT" != "" ]]; then
    # Add template command
    add_template "$TEMPLATE_OUTPUT" "$TEMPLATE_NAME"
  else
    # Remove template command
    remove_template "$TEMPLATE_NAME"
  fi
  
  exit 0
}

main "$@" 